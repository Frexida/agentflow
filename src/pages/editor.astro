---
import Base from '../layouts/Base.astro';
---

<Base title="AgentFlow ã‚¨ãƒ‡ã‚£ã‚¿">
  <link rel="stylesheet" href="/drawflow.min.css" />
  <style is:global>
    body { background: #0f0f0f; }

    #drawflow {
      width: 100vw;
      height: calc(100vh - 48px);
      background: #0f0f0f;
    }
    .toolbar {
      height: 48px;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 12px;
      border-bottom: 1px solid #2a2a2a;
    }
    .toolbar .org-name {
      color: #9ca3af;
      font-size: 13px;
      margin-right: 8px;
      padding: 4px 8px;
      background: #1f1f1f;
      border-radius: 4px;
      border: 1px solid #333;
    }
    .toolbar button {
      padding: 6px 14px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: background 150ms;
    }
    .toolbar button:hover { background: #2563eb; }
    .toolbar button.secondary { background: #333; }
    .toolbar button.secondary:hover { background: #444; }
    .toolbar button.danger { background: #dc2626; }
    .toolbar button.danger:hover { background: #b91c1c; }
    .toolbar .spacer { flex: 1; }

    /* ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚«ãƒ¼ãƒ‰ */
    .agent-card {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 10px;
      min-width: 180px;
      color: #e2e8f0;
      font-family: -apple-system, sans-serif;
      transition: border-color 150ms;
    }
    .agent-card .agent-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .agent-card .agent-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #2a2a2a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    .agent-card .agent-name {
      font-weight: bold;
      font-size: 14px;
    }
    .agent-card .agent-role {
      font-size: 11px;
      color: #6b7280;
      margin-bottom: 4px;
    }
    .agent-card .agent-model {
      font-size: 10px;
      color: #555;
      background: #111;
      padding: 2px 6px;
      border-radius: 4px;
      display: inline-block;
    }

    /* Drawflow overrides */
    .drawflow .drawflow-node {
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
      min-width: auto !important;
    }
    .drawflow .drawflow-node.selected .agent-card {
      border-color: #3b82f6;
      box-shadow: 0 0 12px rgba(59, 130, 246, 0.3);
    }
    .drawflow .connection .main-path {
      stroke: #ef4444 !important;
      stroke-width: 2 !important;
    }
    .drawflow .connection.link-communication .main-path {
      stroke: #3b82f6 !important;
    }
    .drawflow .connection.link-review .main-path {
      stroke: #f59e0b !important;
    }
    .drawflow .drawflow-node .input, .drawflow .drawflow-node .output {
      background: #555 !important;
      border: 1px solid #777 !important;
    }

    /* ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ« */
    #side-panel {
      position: fixed;
      top: 48px;
      right: 0;
      width: 360px;
      height: calc(100vh - 48px);
      background: #141414;
      border-left: 1px solid #2a2a2a;
      transform: translateX(100%);
      transition: transform 150ms ease;
      z-index: 200;
      overflow-y: auto;
      padding: 20px;
    }
    #side-panel.open { transform: translateX(0); }
    #side-panel h3 {
      font-size: 16px;
      margin-bottom: 16px;
      color: #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #side-panel .close-btn {
      background: none;
      border: none;
      color: #6b7280;
      font-size: 20px;
      cursor: pointer;
    }
    #side-panel .close-btn:hover { color: #fff; }
    .field { margin-bottom: 14px; }
    .field label {
      display: block;
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 4px;
    }
    .field input, .field select, .field textarea {
      width: 100%;
      padding: 8px 10px;
      background: #1f1f1f;
      border: 1px solid #333;
      border-radius: 6px;
      color: #e5e7eb;
      font-size: 13px;
      font-family: inherit;
      outline: none;
      transition: border-color 150ms;
    }
    .field input:focus, .field select:focus, .field textarea:focus {
      border-color: #3b82f6;
    }
    .field textarea { min-height: 80px; resize: vertical; }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #e5e7eb;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 300;
      opacity: 0;
      transition: opacity 150ms;
    }
    .toast.show { opacity: 1; }
  </style>

  <div class="toolbar">
    <span class="org-name" id="org-name-display">ç„¡é¡Œã®çµ„ç¹”</span>
    <button id="btn-new-org" class="secondary">ğŸ¢ æ–°è¦çµ„ç¹”</button>
    <button id="btn-add-agent">+ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¿½åŠ </button>
    <button id="btn-auto-layout" class="secondary">â¬¡ è‡ªå‹•æ•´åˆ—</button>
    <div class="spacer"></div>
    <button id="btn-export" class="secondary">ğŸ“¤ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
    <button id="btn-save" class="secondary">ğŸ’¾ ä¿å­˜</button>
    <button id="btn-clear" class="danger">ğŸ—‘ ã‚¯ãƒªã‚¢</button>
  </div>
  <div id="drawflow"></div>

  <div id="side-panel">
    <h3>ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç·¨é›† <button class="close-btn" id="panel-close">âœ•</button></h3>
    <div class="field"><label>ã‚¢ã‚¤ã‚³ãƒ³ (çµµæ–‡å­—)</label><input type="text" id="edit-icon" maxlength="4" /></div>
    <div class="field"><label>åå‰</label><input type="text" id="edit-name" /></div>
    <div class="field"><label>å½¹å‰²</label><input type="text" id="edit-role" /></div>
    <div class="field"><label>æ€§æ ¼</label><textarea id="edit-personality"></textarea></div>
    <div class="field"><label>ãƒ¢ãƒ‡ãƒ«</label>
      <select id="edit-model">
        <option value="anthropic/claude-opus-4-6">claude-opus-4-6</option>
        <option value="openai/gpt-5.3-codex">gpt-5.3-codex</option>
        <option value="anthropic/claude-sonnet-4">claude-sonnet-4</option>
        <option value="google/gemini-2.5-pro">gemini-2.5-pro</option>
      </select>
    </div>
    <div class="field"><label>ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</label><textarea id="edit-prompt" style="min-height:120px"></textarea></div>
    <div class="field"><label>ãƒ„ãƒ¼ãƒ«ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«</label>
      <select id="edit-tools">
        <option value="">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</option>
        <option value="minimal">minimal â€” åŸºæœ¬ãƒ„ãƒ¼ãƒ«ã®ã¿</option>
        <option value="coding">coding â€” ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å‘ã‘</option>
        <option value="messaging">messaging â€” ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°å‘ã‘</option>
        <option value="full">full â€” å…¨ãƒ„ãƒ¼ãƒ«</option>
      </select>
    </div>
    <div class="field"><label>åˆæœŸè¨˜æ†¶ (MEMORY.md)</label><textarea id="edit-memory" style="min-height:80px" placeholder="ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸçŸ¥è­˜ã‚„è¨˜æ†¶..."></textarea></div>
    <hr style="border-color:#333;margin:16px 0" />
    <button id="btn-delete-agent" style="width:100%;padding:8px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px">ğŸ—‘ ã“ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å‰Šé™¤</button>
  </div>

  <div id="link-modal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #333;border-radius:10px;padding:20px;z-index:400;min-width:300px">
    <h3 style="color:#e5e7eb;margin:0 0 16px;font-size:15px">ãƒªãƒ³ã‚¯ç·¨é›†</h3>
    <div class="field"><label>ã‚¿ã‚¤ãƒ—</label>
      <select id="link-type">
        <option value="authority">ğŸ”´ authorityï¼ˆæŒ‡æ®ï¼‰</option>
        <option value="communication">ğŸ”µ communicationï¼ˆé€šä¿¡ï¼‰</option>
        <option value="review">ğŸŸ¡ reviewï¼ˆãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰</option>
      </select>
    </div>
    <div class="field"><label>ãƒ©ãƒ™ãƒ«ï¼ˆèª¬æ˜ï¼‰</label><input type="text" id="link-label" placeholder="ä¾‹: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¾é ¼" /></div>
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="link-modal-save" style="flex:1;padding:8px;background:#3b82f6;color:white;border:none;border-radius:6px;cursor:pointer">ä¿å­˜</button>
      <button id="link-modal-delete" style="padding:8px 12px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointer">å‰Šé™¤</button>
      <button id="link-modal-close" style="padding:8px 12px;background:#333;color:white;border:none;border-radius:6px;cursor:pointer">é–‰ã˜ã‚‹</button>
    </div>
  </div>
  <div id="link-modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:399"></div>

  <div class="toast" id="toast"></div>

  <script src="/drawflow.min.js" is:inline></script>
  <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js" is:inline></script>
  <script is:inline>
  (function() {
    'use strict';

    const STORAGE_KEY = 'agentflow_org';
    const MODELS = [
      'anthropic/claude-opus-4-6',
      'openai/gpt-5.3-codex',
      'anthropic/claude-sonnet-4',
      'google/gemini-2.5-pro'
    ];
    const LINK_TYPES = ['authority', 'communication', 'review'];
    const LINK_COLORS = { authority: '#ef4444', communication: '#3b82f6', review: '#f59e0b' };
    const DEFAULT_ICONS = ['ğŸ‘”', 'âš™ï¸', 'ğŸ”¬', 'ğŸ¨', 'ğŸ‘ï¸', 'ğŸ§ª', 'ğŸ“Š', 'ğŸ›¡ï¸'];

    // --- Organization State ---
    let org = {
      id: crypto.randomUUID(),
      name: 'ç„¡é¡Œã®çµ„ç¹”',
      description: '',
      version: 'v1',
      agents: [],
      links: [],
      groups: []
    };

    // nodeId (drawflow int) -> agentId mapping
    let nodeToAgent = {};
    // connectionId -> linkType
    let connectionTypes = {};

    // --- Drawflow init ---
    const container = document.getElementById('drawflow');
    const editor = new Drawflow(container);
    editor.reroute = true;
    editor.start();

    // --- Helpers ---
    function uid() { return 'a' + crypto.randomUUID().slice(0, 8); }

    function toast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2000);
    }

    function agentById(id) { return org.agents.find(a => a.id === id); }
    function nodeIdForAgent(agentId) {
      return Object.keys(nodeToAgent).find(k => nodeToAgent[k] === agentId);
    }

    function createAgentHTML(agent) {
      return `<div class="agent-card" data-agent-id="${agent.id}">
        <div class="agent-header">
          <div class="agent-icon">${agent.icon || 'ğŸ¤–'}</div>
          <div class="agent-name">${agent.name}</div>
        </div>
        <div class="agent-role">${agent.role || 'æœªè¨­å®š'}</div>
        <div class="agent-model">${(agent.model || MODELS[0]).split('/').pop()}</div>
      </div>`;
    }

    function updateNodeHTML(agentId) {
      const agent = agentById(agentId);
      const nid = nodeIdForAgent(agentId);
      if (!agent || !nid) return;
      const nodeEl = container.querySelector(`#node-${nid}`);
      if (!nodeEl) return;
      const content = nodeEl.querySelector('.drawflow_content_node');
      if (content) content.innerHTML = createAgentHTML(agent);
    }

    // --- Add Agent ---
    function addAgent(agentData, x, y) {
      const agent = {
        id: agentData?.id || uid(),
        name: agentData?.name || `Agent ${org.agents.length + 1}`,
        role: agentData?.role || '',
        personality: agentData?.personality || '',
        icon: agentData?.icon || DEFAULT_ICONS[org.agents.length % DEFAULT_ICONS.length],
        model: agentData?.model || MODELS[0],
        systemPrompt: agentData?.systemPrompt || '',
        toolsProfile: agentData?.toolsProfile || '',
        memory: agentData?.memory || '',
      };
      org.agents.push(agent);

      const px = x ?? 100 + (org.agents.length % 4) * 260;
      const py = y ?? 80 + Math.floor(org.agents.length / 4) * 200;
      const nodeId = editor.addNode(
        agent.id, 1, 1, px, py, 'agent-node', { agentId: agent.id }, createAgentHTML(agent)
      );
      nodeToAgent[nodeId] = agent.id;
      scheduleSave();
      return agent;
    }

    document.getElementById('btn-add-agent').addEventListener('click', () => {
      addAgent();
    });

    // --- Double-click â†’ side panel ---
    let editingAgentId = null;
    const panel = document.getElementById('side-panel');

    editor.on('nodeSelected', function(nodeId) {
      // single click - no action
    });

    container.addEventListener('dblclick', (e) => {
      const card = e.target.closest('.agent-card');
      if (!card) return;
      const agentId = card.dataset.agentId;
      openPanel(agentId);
    });

    function openPanel(agentId) {
      const agent = agentById(agentId);
      if (!agent) return;
      editingAgentId = agentId;
      document.getElementById('edit-icon').value = agent.icon || '';
      document.getElementById('edit-name').value = agent.name || '';
      document.getElementById('edit-role').value = agent.role || '';
      document.getElementById('edit-personality').value = agent.personality || '';
      document.getElementById('edit-model').value = agent.model || MODELS[0];
      document.getElementById('edit-prompt').value = agent.systemPrompt || '';
      document.getElementById('edit-tools').value = agent.toolsProfile || '';
      document.getElementById('edit-memory').value = agent.memory || '';
      panel.classList.add('open');
    }

    function closePanel() {
      panel.classList.remove('open');
      editingAgentId = null;
    }

    document.getElementById('panel-close').addEventListener('click', closePanel);

    // Live editing
    ['edit-icon', 'edit-name', 'edit-role', 'edit-personality', 'edit-model', 'edit-prompt', 'edit-tools', 'edit-memory'].forEach(id => {
      document.getElementById(id).addEventListener('input', () => {
        if (!editingAgentId) return;
        const agent = agentById(editingAgentId);
        if (!agent) return;
        agent.icon = document.getElementById('edit-icon').value;
        agent.name = document.getElementById('edit-name').value;
        agent.role = document.getElementById('edit-role').value;
        agent.personality = document.getElementById('edit-personality').value;
        agent.model = document.getElementById('edit-model').value;
        agent.systemPrompt = document.getElementById('edit-prompt').value;
        agent.toolsProfile = document.getElementById('edit-tools').value;
        agent.memory = document.getElementById('edit-memory').value;
        updateNodeHTML(editingAgentId);
        scheduleSave();
      });
    });

    // --- Delete agent from panel ---
    document.getElementById('btn-delete-agent').addEventListener('click', () => {
      if (!editingAgentId) return;
      const agent = agentById(editingAgentId);
      if (!confirm(`ã€Œ${agent?.name || editingAgentId}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) return;
      const nid = nodeIdForAgent(editingAgentId);
      if (nid) editor.removeNodeId('node-' + nid);
      closePanel();
    });

    // --- Connection / Link management ---
    editor.on('connectionCreated', function(info) {
      const srcAgentId = nodeToAgent[info.output_id];
      const tgtAgentId = nodeToAgent[info.input_id];
      if (!srcAgentId || !tgtAgentId) return;

      const linkId = uid();
      org.links.push({
        id: linkId,
        source: srcAgentId,
        target: tgtAgentId,
        type: 'authority',
      });

      // Store connection key -> link mapping
      const connKey = `${info.output_id}_${info.input_id}`;
      connectionTypes[connKey] = { linkId, type: 'authority' };
      applyConnectionColor(info.output_id, info.input_id, 'authority');
      scheduleSave();
    });

    editor.on('connectionRemoved', function(info) {
      const connKey = `${info.output_id}_${info.input_id}`;
      const ct = connectionTypes[connKey];
      if (ct) {
        org.links = org.links.filter(l => l.id !== ct.linkId);
        delete connectionTypes[connKey];
      }
      scheduleSave();
    });

    editor.on('nodeRemoved', function(nodeId) {
      const agentId = nodeToAgent[nodeId];
      if (agentId) {
        org.agents = org.agents.filter(a => a.id !== agentId);
        org.links = org.links.filter(l => l.source !== agentId && l.target !== agentId);
        delete nodeToAgent[nodeId];
        if (editingAgentId === agentId) closePanel();
      }
      // Clean connectionTypes
      for (const key of Object.keys(connectionTypes)) {
        if (key.startsWith(nodeId + '_') || key.endsWith('_' + nodeId)) {
          delete connectionTypes[key];
        }
      }
      scheduleSave();
    });

    function applyConnectionColor(outId, inId, type) {
      // Find the SVG connection element
      setTimeout(() => {
        const connections = container.querySelectorAll('.connection');
        connections.forEach(conn => {
          const classes = conn.classList;
          const path = conn.querySelector('.main-path');
          if (!path) return;
          // Match by node ids in class
          if (classes.contains(`node_out_node-${outId}`) && classes.contains(`node_in_node-${inId}`)) {
            conn.classList.remove('link-authority', 'link-communication', 'link-review');
            conn.classList.add('link-' + type);
            path.style.stroke = LINK_COLORS[type];
          }
        });
      }, 50);
    }

    function applyAllConnectionColors() {
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        applyConnectionColor(outId, inId, ct.type);
      }
    }

    // Click on connection to cycle link type
    container.addEventListener('click', (e) => {
      const path = e.target.closest('.main-path');
      if (!path) return;
      const conn = path.closest('.connection');
      if (!conn) return;

      // Find which connection this is
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        if (conn.classList.contains(`node_out_node-${outId}`) && conn.classList.contains(`node_in_node-${inId}`)) {
          const idx = LINK_TYPES.indexOf(ct.type);
          const newType = LINK_TYPES[(idx + 1) % LINK_TYPES.length];
          ct.type = newType;
          const link = org.links.find(l => l.id === ct.linkId);
          if (link) link.type = newType;
          applyConnectionColor(outId, inId, newType);
          toast(`ãƒªãƒ³ã‚¯ã‚¿ã‚¤ãƒ—: ${newType}`);
          scheduleSave();
          break;
        }
      }
    });

    // --- Link modal (double-click to edit) ---
    let editingConnKey = null;
    const linkModal = document.getElementById('link-modal');
    const linkOverlay = document.getElementById('link-modal-overlay');

    function openLinkModal(connKey) {
      const ct = connectionTypes[connKey];
      if (!ct) return;
      const link = org.links.find(l => l.id === ct.linkId);
      if (!link) return;
      editingConnKey = connKey;
      document.getElementById('link-type').value = link.type;
      document.getElementById('link-label').value = link.label || '';
      linkModal.style.display = 'block';
      linkOverlay.style.display = 'block';
    }

    function closeLinkModal() {
      linkModal.style.display = 'none';
      linkOverlay.style.display = 'none';
      editingConnKey = null;
    }

    document.getElementById('link-modal-close').addEventListener('click', closeLinkModal);
    linkOverlay.addEventListener('click', closeLinkModal);

    document.getElementById('link-modal-save').addEventListener('click', () => {
      if (!editingConnKey) return;
      const ct = connectionTypes[editingConnKey];
      if (!ct) return;
      const link = org.links.find(l => l.id === ct.linkId);
      if (!link) return;
      const newType = document.getElementById('link-type').value;
      const newLabel = document.getElementById('link-label').value;
      link.type = newType;
      link.label = newLabel || undefined;
      ct.type = newType;
      const [outId, inId] = editingConnKey.split('_');
      applyConnectionColor(outId, inId, newType);
      toast(`ãƒªãƒ³ã‚¯æ›´æ–°: ${newType}${newLabel ? ' â€” ' + newLabel : ''}`);
      scheduleSave();
      closeLinkModal();
    });

    document.getElementById('link-modal-delete').addEventListener('click', () => {
      if (!editingConnKey) return;
      const [outId, inId] = editingConnKey.split('_');
      // Remove from drawflow
      const data = editor.export().drawflow.Home.data;
      const outNode = data[outId];
      if (outNode) {
        for (const [oKey, output] of Object.entries(outNode.outputs)) {
          output.connections = output.connections.filter(c => String(c.node) !== String(inId));
        }
      }
      const inNode = data[inId];
      if (inNode) {
        for (const [iKey, input] of Object.entries(inNode.inputs)) {
          input.connections = input.connections.filter(c => String(c.node) !== String(outId));
        }
      }
      editor.import({ drawflow: { Home: { data } } });
      // Clean up org state
      const ct = connectionTypes[editingConnKey];
      if (ct) org.links = org.links.filter(l => l.id !== ct.linkId);
      delete connectionTypes[editingConnKey];
      setTimeout(applyAllConnectionColors, 100);
      toast('ãƒªãƒ³ã‚¯å‰Šé™¤');
      scheduleSave();
      closeLinkModal();
    });

    container.addEventListener('dblclick', (e) => {
      const path = e.target.closest('.main-path');
      if (!path) return;
      const conn = path.closest('.connection');
      if (!conn) return;
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        if (conn.classList.contains(`node_out_node-${outId}`) && conn.classList.contains(`node_in_node-${inId}`)) {
          openLinkModal(key);
          break;
        }
      }
    });

    // --- Auto Layout (dagre) ---
    document.getElementById('btn-auto-layout').addEventListener('click', () => {
      const data = editor.export().drawflow.Home.data;
      const nodeIds = Object.keys(data);
      if (nodeIds.length === 0) return;

      const g = new dagre.graphlib.Graph();
      g.setGraph({ rankdir: 'TB', nodesep: 80, ranksep: 140 });
      g.setDefaultEdgeLabel(() => ({}));

      nodeIds.forEach(id => g.setNode(id, { width: 200, height: 100 }));
      nodeIds.forEach(id => {
        const node = data[id];
        Object.values(node.outputs || {}).forEach(output => {
          (output.connections || []).forEach(conn => g.setEdge(id, conn.node));
        });
      });

      dagre.layout(g);
      nodeIds.forEach(id => {
        const pos = g.node(id);
        data[id].pos_x = pos.x - 100;
        data[id].pos_y = pos.y - 50;
      });

      editor.import({ drawflow: { Home: { data } } });
      // Re-apply colors after import
      setTimeout(applyAllConnectionColors, 100);
    });

    // --- Export ---
    function validateOrg(org) {
      const warnings = [];
      const errors = [];
      if (org.agents.length === 0) errors.push('ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒ1ã¤ã‚‚ã‚ã‚Šã¾ã›ã‚“');
      const names = org.agents.map(a => a.name);
      const dupes = names.filter((n, i) => names.indexOf(n) !== i);
      if (dupes.length) errors.push(`é‡è¤‡å: ${[...new Set(dupes)].join(', ')}`);
      for (const a of org.agents) {
        if (!a.name || a.name.trim() === '') errors.push(`åå‰æœªè¨­å®šã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ (${a.id})`);
        if (!a.role || a.role.trim() === '') warnings.push(`${a.name}: å½¹å‰²ãŒæœªè¨­å®š`);
        if (!a.systemPrompt || a.systemPrompt.trim() === '') warnings.push(`${a.name}: ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒç©º`);
      }
      // Check for orphan agents (no connections)
      const connectedIds = new Set(org.links.flatMap(l => [l.source, l.target]));
      const orphans = org.agents.filter(a => !connectedIds.has(a.id));
      if (orphans.length > 0 && org.agents.length > 1) {
        warnings.push(`æ¥ç¶šãªã—: ${orphans.map(a => a.name).join(', ')}`);
      }
      return { errors, warnings };
    }

    document.getElementById('btn-export').addEventListener('click', () => {
      const { errors, warnings } = validateOrg(org);
      if (errors.length > 0) {
        alert('âŒ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:\n' + errors.join('\n'));
        return;
      }
      if (warnings.length > 0) {
        if (!confirm('âš ï¸ è­¦å‘Š:\n' + warnings.join('\n') + '\n\nç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ')) return;
      }
      const result = exportToOpenClaw(org);
      // Download config JSON (schema-compliant, for config.apply)
      const configBlob = new Blob([JSON.stringify(result.config, null, 2)], { type: 'application/json' });
      downloadBlob(configBlob, `${org.name || 'agentflow'}-openclaw.json`);
      // Download full export (config + meta + workspace files)
      const fullBlob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' });
      downloadBlob(fullBlob, `${org.name || 'agentflow'}-full-export.json`);
      // Download workspace setup script
      const script = generateSetupScript(org, result);
      const scriptBlob = new Blob([script], { type: 'text/x-shellscript' });
      downloadBlob(scriptBlob, `${org.name || 'agentflow'}-setup.sh`);
      toast('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†ï¼ˆ3ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰');
    });

    function generateSetupScript(org, result) {
      function slugify(s) {
        return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') || 'unnamed';
      }
      const lines = [
        '#!/usr/bin/env bash',
        `# AgentFlow workspace setup â€” ${org.name}`,
        `# Generated: ${new Date().toISOString()}`,
        'set -euo pipefail',
        '',
        'BASE_DIR="${1:-$HOME/.openclaw/workspace}"',
        'echo "Setting up agent workspaces in $BASE_DIR"',
        '',
      ];
      for (const agent of org.agents) {
        const slug = slugify(agent.name || agent.id);
        const files = result.meta.workspaceFiles[agent.id];
        if (!files) continue;
        lines.push(`# --- ${agent.name || agent.id} ---`);
        lines.push(`mkdir -p "$BASE_DIR/${slug}"`);
        for (const [fname, content] of Object.entries(files)) {
          lines.push(`cat > "$BASE_DIR/${slug}/${fname}" << 'AGENTFLOW_EOF'`);
          lines.push(content.trimEnd());
          lines.push('AGENTFLOW_EOF');
        }
        lines.push(`echo "  âœ“ ${agent.name || agent.id}"`);
        lines.push('');
      }
      lines.push('echo "Done. Run: openclaw gateway config.apply"');
      return lines.join('\n') + '\n';
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Inline export function v2 â€” OpenClaw config schema compliant
    function exportToOpenClaw(org) {
      function slugify(s) {
        return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') || 'unnamed';
      }
      function findAgent(id) { return org.agents.find(a => a.id === id); }
      function agentName(id) { return findAgent(id)?.name || id; }

      const GUILD_PH = 'REPLACE_WITH_GUILD_ID';
      const chPH = (id) => 'REPLACE_WITH_CHANNEL_ID_FOR_' + slugify(id).toUpperCase();
      const primaryModel = (org.agents[0]?.model) || 'anthropic/claude-opus-4-6';
      const baseWorkspace = '/home/user/.openclaw/workspace';

      // agents.list
      const list = org.agents.map(agent => {
        const agentSlug = slugify(agent.name || agent.id);
        const authTargets = org.links
          .filter(l => l.source === agent.id && l.type === 'authority')
          .map(l => l.target);
        const entry = {
          id: agent.id,
          name: agent.name,
          workspace: baseWorkspace + '/' + agentSlug,
          identity: { name: agent.name },
        };
        if (agent.model && agent.model !== primaryModel) entry.model = agent.model;
        if (agent.icon) entry.identity.avatar = agent.icon;
        if (authTargets.length > 0) entry.subagents = { allowAgents: authTargets };
        if (agent.toolsProfile) entry.tools = { profile: agent.toolsProfile };
        return entry;
      });

      // bindings
      const bindings = org.agents.map(agent => ({
        agentId: agent.id,
        match: { channel: 'discord', guildId: GUILD_PH, peer: { kind: 'channel', id: chPH(agent.id) } },
      }));

      // channels
      const channelConfigs = {};
      for (const agent of org.agents) {
        channelConfigs[chPH(agent.id)] = { allow: true, requireMention: false };
      }

      const config = {
        agents: {
          defaults: { model: { primary: primaryModel }, workspace: baseWorkspace },
          list,
        },
        bindings,
        channels: {
          discord: {
            enabled: true,
            groupPolicy: 'allowlist',
            guilds: { [GUILD_PH]: { requireMention: true, users: ['*'], channels: channelConfigs } },
          },
        },
        commands: { native: 'auto', nativeSkills: 'auto' },
      };

      // workspace files (SOUL.md + AGENTS.md per agent)
      const workspaceFiles = {};
      for (const agent of org.agents) {
        const files = {};
        // SOUL.md
        const soulParts = ['# ' + (agent.name || agent.id)];
        if (agent.personality) soulParts.push('## Personality\n' + agent.personality);
        if (agent.role) soulParts.push('## Role\n' + agent.role);
        if (agent.systemPrompt) soulParts.push('## Instructions\n' + agent.systemPrompt);
        // Org relationships in SOUL.md
        const rels = [];
        const superiors = org.links.filter(l => l.target === agent.id && l.type === 'authority').map(l => agentName(l.source));
        if (superiors.length) rels.push('- **Reports to:** ' + superiors.join(', ') + ' â€” prioritize their instructions');
        const subs = org.links.filter(l => l.source === agent.id && l.type === 'authority').map(l => agentName(l.target));
        if (subs.length) rels.push('- **Manages:** ' + subs.join(', ') + ' â€” can delegate tasks via sessions_spawn');
        const comms = org.links.filter(l => (l.source === agent.id || l.target === agent.id) && l.type === 'communication')
          .map(l => agentName(l.source === agent.id ? l.target : l.source));
        if (comms.length) rels.push('- **Communicates with:** ' + comms.join(', '));
        const reviewTargets = org.links.filter(l => l.source === agent.id && l.type === 'review').map(l => agentName(l.target));
        if (reviewTargets.length) rels.push('- **Reviews work of:** ' + reviewTargets.join(', '));
        const reviewedBy = org.links.filter(l => l.target === agent.id && l.type === 'review').map(l => agentName(l.source));
        if (reviewedBy.length) rels.push('- **Reviewed by:** ' + reviewedBy.join(', '));
        if (rels.length) soulParts.push('## Organization\n' + rels.join('\n'));
        files['SOUL.md'] = soulParts.join('\n\n') + '\n';

        // AGENTS.md
        const agLines = ['# AGENTS.md â€” Organization Context for ' + (agent.name || agent.id), ''];
        agLines.push('## Organization: ' + org.name);
        if (org.description) agLines.push('\n' + org.description);
        agLines.push('', '## Team Members');
        for (const a of org.agents) {
          const marker = a.id === agent.id ? ' **(you)**' : '';
          agLines.push('- **' + (a.name || a.id) + '**' + marker + ': ' + (a.role || 'No role defined'));
        }
        agLines.push('', '## Relationships');
        const authLinks = org.links.filter(l => l.type === 'authority');
        const commLinks2 = org.links.filter(l => l.type === 'communication');
        const revLinks2 = org.links.filter(l => l.type === 'review');
        if (authLinks.length) {
          agLines.push('### Authority (command chain)');
          for (const l of authLinks) agLines.push('- ' + agentName(l.source) + ' â†’ ' + agentName(l.target));
        }
        if (commLinks2.length) {
          agLines.push('### Communication');
          for (const l of commLinks2) agLines.push('- ' + agentName(l.source) + ' â†” ' + agentName(l.target));
        }
        if (revLinks2.length) {
          agLines.push('### Review');
          for (const l of revLinks2) agLines.push('- ' + agentName(l.source) + ' reviews ' + agentName(l.target));
        }
        if (!authLinks.length && !commLinks2.length && !revLinks2.length) {
          agLines.push('- Flat structure (no links defined)');
        }
        if (org.groups.length) {
          agLines.push('', '## Groups');
          for (const g of org.groups) {
            agLines.push('- **' + g.name + '**: ' + g.agentIds.map(id => agentName(id)).join(', '));
          }
        }
        files['AGENTS.md'] = agLines.join('\n') + '\n';

        if (agent.memory) files['MEMORY.md'] = '# Initial Memory\n\n' + agent.memory + '\n';
        workspaceFiles[agent.id] = files;
      }

      return {
        config,
        meta: {
          exportedFrom: 'agentflow',
          version: 'v2',
          organizationId: org.id,
          organizationName: org.name,
          exportedAt: new Date().toISOString(),
          workspaceFiles,
          links: org.links.map(l => ({ source: l.source, target: l.target, type: l.type, ...(l.label && { label: l.label }) })),
        },
      };
    }

    // --- Save / Load ---
    let saveTimer = null;
    function scheduleSave() {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(saveToStorage, 5000);
    }

    function saveToStorage() {
      const drawflowData = editor.export();
      const state = { org, nodeToAgent, connectionTypes, drawflow: drawflowData };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      updateOrgDisplay();
      toast('ä¿å­˜ã—ã¾ã—ãŸ');
    }

    function loadFromStorage() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      try {
        const state = JSON.parse(raw);
        org = state.org;
        nodeToAgent = state.nodeToAgent || {};
        connectionTypes = state.connectionTypes || {};
        if (state.drawflow) {
          editor.import(state.drawflow);
          setTimeout(applyAllConnectionColors, 100);
        }
        updateOrgDisplay();
        return true;
      } catch (e) {
        console.error('Failed to load:', e);
        return false;
      }
    }

    function updateOrgDisplay() {
      document.getElementById('org-name-display').textContent = org.name;
    }

    document.getElementById('btn-save').addEventListener('click', () => {
      clearTimeout(saveTimer);
      saveToStorage();
    });

    // --- New Organization ---
    document.getElementById('btn-new-org').addEventListener('click', () => {
      const name = prompt('çµ„ç¹”åã‚’å…¥åŠ›:');
      if (!name) return;
      editor.clear();
      org = {
        id: crypto.randomUUID(),
        name,
        description: '',
        version: 'v1',
        agents: [],
        links: [],
        groups: []
      };
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();
      updateOrgDisplay();
      saveToStorage();
    });

    // --- Clear ---
    document.getElementById('btn-clear').addEventListener('click', () => {
      if (!confirm('å…¨ãƒãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
      editor.clear();
      org.agents = [];
      org.links = [];
      org.groups = [];
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();
      scheduleSave();
    });

    // --- Init: load from storage or create demo ---
    if (!loadFromStorage()) {
      addAgent({ name: 'PM', role: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†', icon: 'ğŸ‘”', model: MODELS[0] });
      addAgent({ name: 'ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢', role: 'å®Ÿè£…æ‹…å½“', icon: 'âš™ï¸', model: MODELS[1] });
      addAgent({ name: 'ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼', role: 'ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼', icon: 'ğŸ‘ï¸', model: MODELS[2] });
    }

  })();
  </script>
</Base>
