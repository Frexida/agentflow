---
import Base from '../layouts/Base.astro';
const base = import.meta.env.BASE_URL.replace(/\/$/, '');
---

<Base title="AgentFlow Editor">
  <link rel="stylesheet" href={`${base}/drawflow.min.css`} />
  <!-- Google Fonts: Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style is:global>
    /* ‚îÄ‚îÄ Design Tokens (8px grid, semantic colors, WCAG AA contrast) ‚îÄ‚îÄ */
    :root {
      /* Spacing ‚Äî 8px grid */
      --sp-1: 4px;   /* half-step */
      --sp-2: 8px;
      --sp-3: 12px;
      --sp-4: 16px;
      --sp-5: 20px;
      --sp-6: 24px;
      --sp-8: 32px;
      --sp-10: 40px;
      --sp-12: 48px;

      /* Surface colors (dark theme) */
      --bg-base: #0f0f0f;
      --bg-raised: #1a1a1a;
      --bg-overlay: #141414;
      --bg-input: #1f1f1f;
      --bg-inset: #111111;

      /* Border colors */
      --border-subtle: #2a2a2a;
      --border-default: #333333;
      --border-hover: #444444;

      /* Text colors ‚Äî all pass WCAG AA on dark bg */
      --text-primary: #e5e7eb;    /* contrast 12.6:1 on #1a1a1a */
      --text-secondary: #9ca3af;  /* contrast 5.7:1 on #1a1a1a ‚Äî AA */
      --text-tertiary: #6b7280;   /* contrast 3.8:1 on #0f0f0f ‚Äî AA-large */
      --text-muted: #555555;

      /* Accent colors */
      --accent-blue: #3b82f6;
      --accent-blue-hover: #2563eb;
      --accent-blue-glow: rgba(59, 130, 246, 0.3);
      --accent-red: #ef4444;
      --accent-red-hover: #dc2626;
      --accent-red-dark: #b91c1c;
      --accent-yellow: #f59e0b;
      --accent-green: #22c55e;
      --accent-green-glow: rgba(34, 197, 94, 0.5);

      /* Radii */
      --radius-sm: 4px;
      --radius-md: 8px;
      --radius-lg: 12px;
      --radius-pill: 9999px;

      /* Transitions */
      --ease-out: cubic-bezier(0.4, 0, 0.2, 1);
      --duration-fast: 150ms;
      --duration-normal: 200ms;
      --duration-slow: 300ms;

      /* Focus ring ‚Äî accessibility */
      --focus-ring: 0 0 0 2px var(--bg-base), 0 0 0 4px var(--accent-blue);
    }

    *, *::before, *::after {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      box-sizing: border-box;
    }
    body { background: var(--bg-base); }

    /* Focus visible ‚Äî keyboard accessibility */
    :focus-visible {
      outline: none;
      box-shadow: var(--focus-ring);
    }
    :focus:not(:focus-visible) { outline: none; }

    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border-default); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
    /* Firefox */
    * { scrollbar-width: thin; scrollbar-color: var(--border-default) transparent; }

    #drawflow {
      width: 100vw;
      height: calc(100vh - var(--sp-12));
      background: var(--bg-base);
    }

    /* Grid background ‚Äî 200√ó100 cells matching agent node size */
    #drawflow .drawflow {
      background-image:
        linear-gradient(to right,  var(--border-subtle) 1px, transparent 1px),
        linear-gradient(to bottom, var(--border-subtle) 1px, transparent 1px);
      background-size: 200px 100px;
      background-position: 0 0;
    }

    /* ‚îÄ‚îÄ Toolbar ‚îÄ‚îÄ */
    .toolbar {
      height: var(--sp-12);
      background: var(--bg-raised);
      display: flex;
      align-items: center;
      gap: var(--sp-2);
      padding: 0 var(--sp-4);
      border-bottom: 1px solid var(--border-subtle);
    }
    .toolbar .org-name {
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      margin-right: var(--sp-2);
      padding: var(--sp-1) var(--sp-3);
      background: var(--bg-input);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-default);
    }
    .toolbar button {
      padding: var(--sp-1) var(--sp-3);
      height: var(--sp-8);
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: var(--sp-1);
      transition: background var(--duration-fast) var(--ease-out),
                  transform var(--duration-fast) var(--ease-out),
                  box-shadow var(--duration-fast) var(--ease-out);
      white-space: nowrap;
    }
    .toolbar button:hover {
      background: var(--accent-blue-hover);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px var(--accent-blue-glow);
    }
    .toolbar button:active { transform: translateY(0); box-shadow: none; }
    .toolbar button.secondary {
      background: var(--bg-input);
      border: 1px solid var(--border-default);
      color: var(--text-primary);
    }
    .toolbar button.secondary:hover {
      background: var(--border-default);
      border-color: var(--border-hover);
      box-shadow: 0 2px 8px rgba(255,255,255,0.04);
    }
    .toolbar button.danger { background: var(--accent-red-hover); }
    .toolbar button.danger:hover { background: var(--accent-red-dark); box-shadow: 0 2px 8px rgba(220,38,38,0.3); }
    .toolbar .spacer { flex: 1; }

    /* Live badge pulse */
    @keyframes livePulse {
      0%, 100% { box-shadow: 0 0 0 0 var(--accent-green-glow); }
      50% { box-shadow: 0 0 0 6px rgba(34,197,94,0); }
    }
    .toolbar .live-badge {
      animation: livePulse 2s ease-in-out infinite;
    }

    /* ‚îÄ‚îÄ Agent Card ‚îÄ‚îÄ */
    .agent-card {
      background: var(--bg-raised);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-lg);
      padding: var(--sp-3);
      min-width: 192px; /* 24 √ó 8px grid */
      color: var(--text-primary);
      transition: border-color var(--duration-normal) var(--ease-out),
                  transform var(--duration-normal) var(--ease-out),
                  box-shadow var(--duration-normal) var(--ease-out);
    }
    .agent-card:hover {
      transform: scale(1.03);
      border-color: var(--border-hover);
      box-shadow: 0 0 24px var(--accent-blue-glow), 0 var(--sp-1) var(--sp-4) rgba(0,0,0,0.3);
    }
    .agent-card .agent-header {
      display: flex;
      align-items: center;
      gap: var(--sp-2);
      margin-bottom: var(--sp-2);
    }
    .agent-card .agent-icon {
      width: var(--sp-8);
      height: var(--sp-8);
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, #1e3a5f 0%, #2d2640 50%, #1a3a2a 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 17px;
      box-shadow: 0 2px var(--sp-2) rgba(0,0,0,0.3);
      flex-shrink: 0;
    }
    .agent-card .agent-name {
      font-weight: 600;
      font-size: 14px;
      letter-spacing: -0.01em;
      color: var(--text-primary);
    }
    .agent-card .agent-role {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-bottom: var(--sp-2);
      line-height: 1.4;
    }
    .agent-card .agent-model {
      font-size: 10px;
      color: var(--text-secondary);
      background: var(--bg-inset);
      padding: var(--sp-1) var(--sp-3);
      border-radius: var(--radius-pill);
      border: 1px solid var(--border-default);
      display: inline-block;
      font-weight: 500;
      letter-spacing: 0.02em;
    }

    /* ‚îÄ‚îÄ Drawflow overrides ‚îÄ‚îÄ */
    .drawflow .drawflow-node {
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
      min-width: auto !important;
    }
    .drawflow .drawflow-node.selected .agent-card {
      border-color: var(--accent-blue);
      box-shadow: 0 0 var(--sp-4) var(--accent-blue-glow), 0 0 var(--sp-8) rgba(59, 130, 246, 0.1);
    }

    /* ‚îÄ‚îÄ Connection lines ‚îÄ‚îÄ */
    .drawflow .connection .main-path {
      stroke: #ef4444 !important;
      stroke-width: 2 !important;
      stroke-linecap: square !important;
      stroke-linejoin: round !important;
      fill: none !important;
      marker-end: url(#arrow-authority) !important;
      transition: stroke-width 200ms, filter 200ms;
    }
    .drawflow .connection:hover .main-path {
      stroke-width: 3.5 !important;
      filter: drop-shadow(0 0 6px rgba(239, 68, 68, 0.5));
    }
    .drawflow .connection.link-communication .main-path {
      stroke: #3b82f6 !important;
      stroke-dasharray: 8 4 !important;
      marker-end: url(#arrow-communication) !important;
    }
    .drawflow .connection.link-communication:hover .main-path {
      filter: drop-shadow(0 0 6px rgba(59, 130, 246, 0.5));
    }
    .drawflow .connection.link-review .main-path {
      stroke: #f59e0b !important;
      stroke-dasharray: 3 3 !important;
      marker-end: url(#arrow-review) !important;
    }
    .drawflow .connection.link-review:hover .main-path {
      filter: drop-shadow(0 0 6px rgba(245, 158, 11, 0.5));
    }
    /* Bidirectional: both-end arrows */
    .drawflow .connection.link-bidirectional .main-path {
      marker-start: url(#arrow-start-authority) !important;
    }
    .drawflow .connection.link-bidirectional.link-communication .main-path {
      marker-start: url(#arrow-start-communication) !important;
    }
    .drawflow .connection.link-bidirectional.link-review .main-path {
      marker-start: url(#arrow-start-review) !important;
    }
    /* Structure mode toggle */
    .toolbar .mode-toggle {
      display: inline-flex;
      background: var(--bg-input);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      overflow: hidden;
      height: var(--sp-8);
    }
    .toolbar .mode-toggle button {
      border-radius: 0;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      padding: var(--sp-1) var(--sp-3);
      font-size: 12px;
      height: 100%;
      margin: 0;
      box-shadow: none;
    }
    .toolbar .mode-toggle button:hover {
      background: var(--border-default);
      transform: none;
      box-shadow: none;
    }
    .toolbar .mode-toggle button.active {
      background: var(--accent-blue);
      color: white;
    }
    .toolbar .mode-toggle button.active:hover {
      background: var(--accent-blue-hover);
    }
    .drawflow .drawflow-node .input, .drawflow .drawflow-node .output {
      background: #555 !important;
      border: 1px solid #777 !important;
    }
    /* Vertical ports: input on top, output on bottom */
    .drawflow .drawflow-node .inputs {
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      width: 100% !important;
      display: flex;
      justify-content: center;
      gap: 8px;
    }
    .drawflow .drawflow-node .outputs {
      position: absolute;
      bottom: -12px;
      left: 0;
      right: 0;
      width: 100% !important;
      display: flex;
      justify-content: center;
      gap: 8px;
    }
    .drawflow .drawflow-node .input, .drawflow .drawflow-node .output {
      position: relative !important;
      top: auto !important;
      right: auto !important;
      left: auto !important;
      bottom: auto !important;
    }
    /* Left side: input_2 */
    .drawflow .drawflow-node .input.input_2 {
      position: absolute !important;
      left: -12px !important;
      top: 50% !important;
      right: auto !important;
      bottom: auto !important;
      transform: translateY(-50%);
    }
    /* Right side: output_2 */
    .drawflow .drawflow-node .output.output_2 {
      position: absolute !important;
      right: -12px !important;
      top: 50% !important;
      left: auto !important;
      bottom: auto !important;
      transform: translateY(-50%);
    }

    /* Side panel */
    #side-panel {
      position: fixed;
      top: var(--sp-12);
      right: 0;
      width: 360px;
      height: calc(100vh - var(--sp-12));
      background: var(--bg-overlay);
      border-left: 1px solid var(--border-subtle);
      transform: translateX(100%);
      transition: transform var(--duration-slow) var(--ease-out);
      z-index: 200;
      overflow-y: auto;
      padding: var(--sp-5);
    }
    #side-panel.open { transform: translateX(0); }
    #side-panel h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: var(--sp-4);
      color: var(--text-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #side-panel .close-btn {
      background: none;
      border: none;
      color: var(--text-tertiary);
      font-size: 20px;
      cursor: pointer;
      padding: var(--sp-1);
      border-radius: var(--radius-sm);
      transition: color var(--duration-fast);
    }
    #side-panel .close-btn:hover { color: white; }
    .field { margin-bottom: var(--sp-4); }
    .field label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-tertiary);
      margin-bottom: var(--sp-1);
      letter-spacing: 0.01em;
    }
    .field input, .field select, .field textarea {
      width: 100%;
      padding: var(--sp-2) var(--sp-3);
      background: var(--bg-input);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      outline: none;
      transition: border-color var(--duration-fast) var(--ease-out),
                  box-shadow var(--duration-fast) var(--ease-out);
    }
    .field input:focus, .field select:focus, .field textarea:focus {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
    }
    .field textarea { min-height: 80px; resize: vertical; }

    /* Toast */
    @keyframes toastIn {
      from { opacity: 0; transform: translateY(12px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0) scale(1); }
      to { opacity: 0; transform: translateY(8px) scale(0.97); }
    }
    .toast {
      position: fixed;
      bottom: var(--sp-6);
      right: var(--sp-6);
      background: var(--bg-raised);
      border: 1px solid var(--border-default);
      color: var(--text-primary);
      padding: var(--sp-3) var(--sp-5);
      border-radius: var(--radius-lg);
      font-size: 13px;
      font-weight: 500;
      z-index: 300;
      opacity: 0;
      transform: translateY(var(--sp-2));
      box-shadow: 0 var(--sp-1) var(--sp-5) rgba(0,0,0,0.4);
      pointer-events: none;
    }
    .toast.show {
      animation: toastIn 250ms ease-out forwards;
    }
    .toast.hide {
      animation: toastOut 200ms ease-in forwards;
    }

    /* Onboarding hints */
    .hints-overlay {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(22, 28, 45, 0.92);
      border: 1px solid rgba(59, 130, 246, 0.3);
      color: #cbd5e1;
      padding: 12px 24px;
      border-radius: 12px;
      font-size: 13px;
      z-index: 200;
      display: flex;
      align-items: center;
      gap: 18px;
      backdrop-filter: blur(16px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.03) inset;
    }
    .hints-overlay .hint-item {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    .hints-overlay .hint-key {
      background: rgba(59, 130, 246, 0.15);
      color: #60a5fa;
      padding: 3px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      border: 1px solid rgba(59, 130, 246, 0.2);
    }
    .hints-overlay .hint-close {
      background: none;
      border: none;
      color: #64748b;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      margin-left: 8px;
      transition: color 150ms;
    }
    .hints-overlay .hint-close:hover { color: #e2e8f0; }

    /* Gateway connection ‚Äî status dot */
    .agent-card .agent-status {
      position: absolute;
      top: var(--sp-2);
      right: var(--sp-2);
      width: 10px;
      height: 10px;
      border-radius: var(--radius-pill);
      background: var(--border-default);
      border: 1.5px solid var(--text-muted);
      transition: background var(--duration-slow) var(--ease-out),
                  box-shadow var(--duration-slow) var(--ease-out);
    }
    .agent-card .agent-status.active {
      background: var(--accent-green);
      border-color: #16a34a;
      box-shadow: 0 0 6px var(--accent-green-glow);
    }
    .agent-card .agent-status.idle { background: var(--text-tertiary); border-color: var(--text-muted); }
    .agent-card .agent-status.recent {
      background: var(--accent-yellow);
      border-color: #d97706;
      box-shadow: 0 0 6px rgba(245,158,11,0.4);
    }
    .agent-card .agent-status.busy {
      background: var(--accent-yellow);
      border-color: #d97706;
      box-shadow: 0 0 6px rgba(245,158,11,0.4);
    }

    /* Activity monitor ‚Äî pulse animations */
    @keyframes pulse-glow-green {
      0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
      100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
    }
    @keyframes pulse-glow-blue {
      0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
      100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
    }
    .agent-card.pulse-green {
      animation: pulse-glow-green 1s ease-out 3;
    }
    .agent-card.pulse-blue {
      animation: pulse-glow-blue 1s ease-out 3;
    }
    /* Last activity timestamp */
    .agent-card .agent-last-activity {
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 9px;
      color: var(--text-muted);
      margin-top: var(--sp-1);
      letter-spacing: 0.03em;
    }

    /* Modal open/close animation */
    @keyframes modalIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.92); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes overlayIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    #gateway-overlay[style*="block"], #export-overlay[style*="block"],
    #diff-overlay[style*="block"], #history-overlay[style*="block"],
    #link-modal-overlay[style*="block"], #template-overlay[style*="block"],
    #wizard-overlay[style*="block"] {
      animation: overlayIn 200ms ease-out;
    }
    #gateway-modal[style*="block"], #export-modal[style*="flex"],
    #diff-modal[style*="flex"], #history-modal[style*="flex"],
    #link-modal[style*="block"], #template-modal[style*="block"],
    #wizard-modal[style*="block"] {
      animation: modalIn 250ms ease-out;
    }

    #gateway-modal {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 14px;
      padding: 24px;
      z-index: 700;
      width: 440px;
      max-width: 95vw;
      box-shadow: 0 16px 48px rgba(0,0,0,0.5);
    }
    #gateway-modal h3 { color: #e5e7eb; margin: 0 0 16px; font-size: 16px; display:flex; justify-content:space-between; align-items:center; }
    #gateway-modal .field { margin-bottom: 12px; }
    #gateway-modal .field label { display:block; font-size:12px; color:#9ca3af; margin-bottom:4px; }
    #gateway-modal .field input { width:100%; padding:8px 10px; background:#111; border:1px solid #333; border-radius:6px; color:#e5e7eb; font-size:13px; font-family:monospace; }
    #gateway-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:699; }
    #gateway-status { font-size:12px; color:#6b7280; margin-top:8px; padding:8px; background:#111; border-radius:6px; min-height:24px; }
    #gateway-status.ok { color: #22c55e; }
    #gateway-status.error { color: #ef4444; }

    /* Chat panel */
    #chat-panel {
      position: fixed;
      top: var(--sp-12);
      right: 0;
      width: 400px;
      height: calc(100vh - var(--sp-12));
      background: var(--bg-base);
      border-left: 1px solid var(--border-subtle);
      transform: translateX(100%);
      transition: transform var(--duration-slow) var(--ease-out);
      z-index: 190;
      display: flex;
      flex-direction: column;
    }
    #chat-panel.open { transform: translateX(0); }
    #chat-panel .chat-header {
      padding: 12px 16px;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #e5e7eb;
      font-size: 14px;
      font-weight: 600;
      background: var(--bg-raised);
      flex-shrink: 0;
    }
    #chat-panel .chat-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #chat-panel .chat-agent-icon {
      font-size: 24px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-pill);
      background: linear-gradient(135deg, #1e3a5f 0%, #2d2640 50%, #1a3a2a 100%);
      flex-shrink: 0;
    }
    #chat-panel .chat-header-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    #chat-panel .chat-agent-status {
      font-size: 11px;
      font-weight: 400;
      color: var(--text-muted);
    }
    #chat-panel .chat-agent-status.online { color: var(--accent-green); }
    #chat-panel .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    .chat-msg {
      margin-bottom: 8px;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 13px;
      line-height: 1.5;
      max-width: 85%;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .chat-msg.user {
      background: var(--accent-blue);
      color: #fff;
      margin-left: auto;
      border-bottom-right-radius: 4px;
    }
    .chat-msg.assistant {
      background: var(--bg-raised);
      color: var(--text-primary);
      border: 1px solid var(--border-default);
      border-bottom-left-radius: 4px;
    }
    .chat-msg.system {
      background: var(--bg-inset);
      color: var(--accent-yellow);
      font-size: 11px;
      text-align: center;
      max-width: 100%;
      border-radius: var(--radius-md);
    }
    .chat-msg .msg-ts {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 4px;
      display: block;
    }
    .chat-msg.user .msg-ts { text-align: right; }
    .chat-input-area {
      padding: 10px 12px;
      border-top: 1px solid var(--border-subtle);
      display: flex;
      gap: 8px;
      align-items: flex-end;
      background: var(--bg-raised);
      flex-shrink: 0;
    }
    .chat-input-area textarea {
      flex: 1;
      background: var(--bg-input);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 13px;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
      padding: 8px 10px;
      resize: none;
      max-height: 120px;
      min-height: 36px;
      outline: none;
      transition: border-color var(--duration-fast);
    }
    .chat-input-area textarea:focus {
      border-color: var(--accent-blue);
    }
    .chat-input-area button {
      width: 36px;
      height: 36px;
      border-radius: var(--radius-md);
      background: var(--accent-blue);
      color: white;
      border: none;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: background var(--duration-fast), opacity var(--duration-fast);
    }
    .chat-input-area button:hover { background: var(--accent-blue-hover); }
    .chat-input-area button:disabled { opacity: 0.4; cursor: not-allowed; }
    .chat-not-connected {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
      gap: 12px;
      padding: 24px;
      text-align: center;
    }
    .chat-not-connected .chat-connect-hint { font-size: 14px; }
    .chat-not-connected button {
      padding: 8px 16px;
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 13px;
    }

    /* Message flow animation on connections */
    @keyframes flowPulse {
      0% { opacity: 0.3; }
      50% { opacity: 1; }
      100% { opacity: 0.3; }
    }
    .connection-active .main-path {
      animation: flowPulse 1.5s ease-in-out infinite;
    }

    /* Connection line flow animation */
    @keyframes line-flow {
      0% { stroke-dashoffset: 20; }
      100% { stroke-dashoffset: 0; }
    }
    .drawflow .connection.flowing .main-path {
      stroke-dasharray: 10 10 !important;
      animation: line-flow 0.8s linear infinite !important;
      filter: drop-shadow(0 0 3px currentColor) !important;
    }

    /* Timeline panel */
    #timeline-panel {
      position: fixed;
      top: var(--sp-12);
      right: 0;
      width: 400px;
      height: calc(100vh - var(--sp-12));
      background: var(--bg-base);
      border-left: 1px solid var(--border-subtle);
      transform: translateX(100%);
      transition: transform var(--duration-slow) var(--ease-out);
      z-index: 195;
      display: flex;
      flex-direction: column;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    }
    #timeline-panel.open { transform: translateX(0); }
    #timeline-panel .tl-header {
      padding: 10px 16px;
      border-bottom: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-raised);
      flex-shrink: 0;
    }
    #timeline-panel .tl-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
    }
    #timeline-panel .tl-filter-bar {
      padding: 6px 12px;
      border-bottom: 1px solid #222;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-shrink: 0;
      background: var(--bg-overlay);
    }
    #timeline-panel .tl-filter-btn {
      padding: 3px 10px;
      font-size: 11px;
      border-radius: var(--radius-pill);
      border: 1px solid var(--border-default);
      background: var(--bg-input);
      color: var(--text-secondary);
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      transition: all 150ms;
    }
    #timeline-panel .tl-filter-btn.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }
    #timeline-panel .tl-filter-btn:hover:not(.active) {
      border-color: var(--border-hover);
    }
    #timeline-panel .tl-entries {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
    }
    .tl-entry {
      padding: 6px 12px;
      border-bottom: 1px solid #1a1a1a;
      font-size: 12px;
      line-height: 1.5;
      color: var(--text-secondary);
      transition: background 100ms;
    }
    .tl-entry:hover { background: rgba(255,255,255,0.02); }
    .tl-entry .tl-ts {
      color: var(--text-muted);
      font-size: 11px;
      margin-right: 6px;
    }
    .tl-entry .tl-agent {
      font-weight: 600;
      margin-right: 4px;
    }
    .tl-entry .tl-icon {
      margin-right: 3px;
    }
    .tl-entry .tl-msg {
      color: var(--text-tertiary);
    }
    .tl-empty {
      text-align: center;
      color: var(--text-muted);
      padding: 40px 20px;
      font-size: 13px;
      font-family: 'Inter', sans-serif;
    }
    .tl-count {
      font-size: 10px;
      color: var(--text-muted);
      background: var(--bg-input);
      padding: 1px 6px;
      border-radius: var(--radius-pill);
      margin-left: 4px;
    }
    @media (max-width: 768px) {
      #timeline-panel { width: 100vw; }
    }

    /* Diff preview modal */
    #diff-modal {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
      background: #1e1e2e; border: 1px solid #374151; border-radius: 12px;
      padding: 20px; width: 700px; max-width: 90vw; max-height: 80vh;
      z-index: 601; display: none; flex-direction: column;
    }
    #diff-modal h3 { display: flex; justify-content: space-between; align-items: center; margin: 0 0 12px; }
    #diff-preview {
      background: #0d1117; border: 1px solid #30363d; border-radius: 8px;
      padding: 12px; overflow: auto; flex: 1; min-height: 200px; max-height: 50vh;
      font-size: 12px; line-height: 1.5; white-space: pre; color: #c9d1d9;
    }
    #diff-preview .diff-add { color: #3fb950; }
    #diff-preview .diff-del { color: #f85149; }
    #diff-preview .diff-section { color: #58a6ff; font-weight: bold; }

    /* Export preview modal */
    #export-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:599; }
    #export-modal {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      padding: 24px;
      z-index: 600;
      width: 700px;
      max-width: 95vw;
      max-height: 85vh;
      display: none;
      flex-direction: column;
    }
    #export-modal h3 {
      color: #e5e7eb;
      margin: 0 0 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
    }
    .export-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    .export-tabs button {
      padding: 6px 14px;
      background: #252525;
      color: #9ca3af;
      border: 1px solid #333;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 150ms;
    }
    .export-tabs button.active {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }
    #export-preview {
      flex: 1;
      overflow: auto;
      background: #111;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 16px;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      color: #a5f3fc;
      white-space: pre-wrap;
      word-break: break-word;
      min-height: 300px;
      max-height: 50vh;
      line-height: 1.5;
    }
    .export-stats {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      color: #6b7280;
      font-size: 12px;
    }
    .export-stats span { display:flex; align-items:center; gap:4px; }
    .export-actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }
    .export-actions button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      transition: background 150ms;
    }
    .export-actions .btn-download { background: #3b82f6; color: white; }
    .export-actions .btn-download:hover { background: #2563eb; }
    .export-actions .btn-copy { background: #333; color: #e5e7eb; }
    .export-actions .btn-copy:hover { background: #444; }
    .export-actions .btn-close { background: #252525; color: #9ca3af; margin-left: auto; }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .toolbar {
        flex-wrap: wrap;
        height: auto;
        padding: 8px;
        gap: 6px;
      }
      .toolbar .spacer { display: none; }
      .toolbar button { padding: 5px 10px; font-size: 12px; }
      .toolbar .org-name { font-size: 12px; width: 100%; margin-bottom: 4px; }
      #side-panel { width: 100vw; }
      #group-panel { width: 100vw; }
      #drawflow { height: calc(100vh - 90px); }
      .hints-overlay {
        flex-wrap: wrap;
        width: 90vw;
        gap: 8px;
        padding: 10px 14px;
        font-size: 12px;
      }
      #export-modal { width: 95vw; padding: 16px; }
      #export-preview { font-size: 11px; min-height: 200px; }
    }
    /* ‚îÄ‚îÄ Task Wizard ‚îÄ‚îÄ */
    #wizard-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:509; }
    #wizard-modal {
      display: none;
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-raised);
      border: 1px solid var(--border-default);
      border-radius: var(--radius-lg);
      padding: var(--sp-6);
      z-index: 510;
      width: 680px;
      max-width: 95vw;
      max-height: 90vh;
      overflow-y: auto;
    }
    #wizard-modal h3 {
      color: var(--text-primary);
      margin: 0 0 var(--sp-2);
      font-size: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #wizard-modal .wizard-subtitle {
      color: var(--text-tertiary);
      font-size: 13px;
      margin-bottom: var(--sp-5);
    }
    .wizard-cards {
      display: flex;
      flex-direction: column;
      gap: var(--sp-3);
      margin-bottom: var(--sp-5);
    }
    .wizard-card {
      text-align: left;
      padding: var(--sp-5);
      background: var(--bg-input);
      border: 2px solid var(--border-default);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      cursor: pointer;
      transition: border-color var(--duration-normal) var(--ease-out),
                  transform var(--duration-normal) var(--ease-out),
                  box-shadow var(--duration-normal) var(--ease-out);
    }
    .wizard-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 16px rgba(0,0,0,0.3);
      border-color: var(--border-hover);
    }
    .wizard-card.selected {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15), 0 4px 16px rgba(0,0,0,0.3);
    }
    .wizard-card .wc-title {
      font-size: 16px;
      font-weight: 700;
      margin-bottom: var(--sp-1);
    }
    .wizard-card .wc-desc {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: var(--sp-2);
      line-height: 1.5;
    }
    .wizard-card .wc-examples {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-bottom: var(--sp-1);
    }
    .wizard-card .wc-preset {
      font-size: 11px;
      color: var(--accent-blue);
      font-weight: 500;
    }
    .wizard-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .wizard-footer .wizard-ref {
      font-size: 10px;
      color: var(--text-muted);
      font-style: italic;
    }
    .wizard-footer .wizard-actions {
      display: flex;
      gap: var(--sp-2);
    }
    #wizard-apply {
      padding: var(--sp-2) var(--sp-5);
      background: var(--accent-blue);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: background var(--duration-fast), opacity var(--duration-fast);
    }
    #wizard-apply:hover { background: var(--accent-blue-hover); }
    #wizard-apply:disabled { opacity: 0.4; cursor: not-allowed; }
    #wizard-cancel {
      padding: var(--sp-2) var(--sp-4);
      background: var(--bg-input);
      border: 1px solid var(--border-default);
      color: var(--text-secondary);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: 13px;
    }

    @media (max-width: 480px) {
      .toolbar button { padding: 4px 8px; font-size: 11px; }
      .agent-card { min-width: 140px; padding: 8px; }
      .agent-card .agent-header { gap: 6px; }
      .agent-card .agent-icon { width: 26px; height: 26px; font-size: 14px; }
      .agent-card .agent-name { font-size: 13px; }
    }
  </style>

  <div class="toolbar">
    <span class="org-name" id="org-name-display">Untitled Organization</span>
    <button id="btn-new-org" class="secondary">üè¢ New</button>
    <button id="btn-add-agent">+ Add Agent</button>
    <button id="btn-auto-layout" class="secondary">‚¨° Auto Layout</button>
    <button id="btn-groups" class="secondary">üìÅ Groups</button>
    <button id="btn-templates" class="secondary">üìã Templates</button>
    <button id="btn-wizard" class="secondary">üß© Wizard</button>
    <div class="mode-toggle">
      <button id="btn-mode-graph" class="active" title="Graph mode (free connections)">üîÑ Graph</button>
      <button id="btn-mode-tree" title="Tree mode (no cycles, single parent)">üå≤ Tree</button>
    </div>
    <button id="btn-timeline" class="secondary">üìã Timeline</button>
    <div class="spacer"></div>
    <button id="btn-gateway" class="secondary" style="background:#1a1a2e;border:1px solid #333">üîå Connect</button>
    <button id="btn-import" class="secondary">üì• Import</button>
    <input type="file" id="import-file" accept=".json" style="display:none" />
    <button id="btn-export" class="secondary">üì§ Export</button>
    <button id="btn-save" class="secondary">üíæ Save</button>
    <button id="btn-clear" class="danger">üóë Clear</button>
  </div>
  <svg style="position:absolute;width:0;height:0">
    <defs>
      <marker id="arrow-authority" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 1 1.5 L 10 6 L 1 10.5 Q 3 6 1 1.5 z" fill="#ef4444" />
      </marker>
      <marker id="arrow-communication" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 1 1.5 L 10 6 L 1 10.5 Q 3 6 1 1.5 z" fill="#3b82f6" />
      </marker>
      <marker id="arrow-review" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 1 1.5 L 10 6 L 1 10.5 Q 3 6 1 1.5 z" fill="#f59e0b" />
      </marker>
      <!-- Bidirectional start markers -->
      <marker id="arrow-start-authority" viewBox="0 0 12 12" refX="2" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 11 1.5 L 2 6 L 11 10.5 Q 9 6 11 1.5 z" fill="#ef4444" />
      </marker>
      <marker id="arrow-start-communication" viewBox="0 0 12 12" refX="2" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 11 1.5 L 2 6 L 11 10.5 Q 9 6 11 1.5 z" fill="#3b82f6" />
      </marker>
      <marker id="arrow-start-review" viewBox="0 0 12 12" refX="2" refY="6" markerWidth="10" markerHeight="10" orient="auto-start-reverse">
        <path d="M 11 1.5 L 2 6 L 11 10.5 Q 9 6 11 1.5 z" fill="#f59e0b" />
      </marker>
    </defs>
  </svg>
  <div id="drawflow"></div>

  <div id="side-panel">
    <h3>Edit Agent <button class="close-btn" id="panel-close">‚úï</button></h3>
    <div class="field"><label>Icon (emoji)</label><input type="text" id="edit-icon" maxlength="4" /></div>
    <div class="field"><label>Name</label><input type="text" id="edit-name" /></div>
    <div class="field"><label>Role</label><input type="text" id="edit-role" /></div>
    <div class="field"><label>Personality</label><textarea id="edit-personality"></textarea></div>
    <div class="field"><label>Model</label>
      <select id="edit-model">
        <option value="anthropic/claude-opus-4-6">claude-opus-4-6</option>
        <option value="openai/gpt-5.3-codex">gpt-5.3-codex</option>
        <option value="anthropic/claude-sonnet-4">claude-sonnet-4</option>
        <option value="google/gemini-2.5-pro">gemini-2.5-pro</option>
      </select>
    </div>
    <div class="field"><label>System Prompt</label><textarea id="edit-prompt" style="min-height:120px"></textarea></div>
    <div class="field"><label>Tool Profile</label>
      <select id="edit-tools">
        <option value="">Default</option>
        <option value="minimal">minimal ‚Äî Basic tools only</option>
        <option value="coding">coding ‚Äî For coding</option>
        <option value="messaging">messaging ‚Äî For messaging</option>
        <option value="full">full ‚Äî All tools</option>
      </select>
    </div>
    <div class="field"><label>Initial Memory (MEMORY.md)</label><textarea id="edit-memory" style="min-height:80px" placeholder="Initial knowledge or memories for this agent..."></textarea></div>
    <hr style="border-color:#333;margin:16px 0" />
    <button id="btn-delete-agent" style="width:100%;padding:8px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px">üóë Delete This Agent</button>
  </div>

  <div id="group-panel" style="position:fixed;top:48px;left:0;width:320px;height:calc(100vh - 48px);background:#141414;border-right:1px solid #2a2a2a;transform:translateX(-100%);transition:transform 150ms ease;z-index:200;overflow-y:auto;padding:20px">
    <h3 style="color:#e5e7eb;font-size:16px;margin:0 0 16px;display:flex;justify-content:space-between;align-items:center">
      Group Management <button id="group-panel-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button>
    </h3>
    <button id="btn-add-group" style="width:100%;padding:8px;background:#3b82f6;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px;margin-bottom:16px">+ Add Group</button>
    <div id="group-list"></div>
  </div>

  <div id="link-modal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #333;border-radius:10px;padding:20px;z-index:400;min-width:300px">
    <h3 style="color:#e5e7eb;margin:0 0 16px;font-size:15px">Edit Link</h3>
    <div class="field"><label>Type</label>
      <select id="link-type">
        <option value="authority">üî¥ Authority (command)</option>
        <option value="communication">üîµ Communication</option>
        <option value="review">üü° Review</option>
      </select>
    </div>
    <div class="field"><label>Direction</label>
      <div id="link-direction-toggle" style="display:flex;gap:4px">
        <button data-dir="unidirectional" style="flex:1;padding:6px;background:#333;color:white;border:1px solid #555;border-radius:6px;cursor:pointer;font-size:14px" class="active">‚Üí One-way</button>
        <button data-dir="bidirectional" style="flex:1;padding:6px;background:#333;color:white;border:1px solid #555;border-radius:6px;cursor:pointer;font-size:14px">‚Üî Both</button>
      </div>
    </div>
    <div class="field"><label>Label (description)</label><input type="text" id="link-label" placeholder="e.g. Code review request" /></div>
    <div style="display:flex;gap:8px;margin-top:12px">
      <button id="link-modal-save" style="flex:1;padding:8px;background:#3b82f6;color:white;border:none;border-radius:6px;cursor:pointer">Save</button>
      <button id="link-modal-delete" style="padding:8px 12px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointer">Delete</button>
      <button id="link-modal-close" style="padding:8px 12px;background:#333;color:white;border:none;border-radius:6px;cursor:pointer">Close</button>
    </div>
  </div>
  <div id="link-modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:399"></div>

  <!-- Gateway connection modal -->
  <div id="gateway-overlay"></div>
  <div id="gateway-modal">
    <h3>üîå Connect to OpenClaw Gateway <button id="gateway-modal-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button></h3>
    <div class="field">
      <label>Gateway URL</label>
      <input type="text" id="gw-url" placeholder="ws://127.0.0.1:18789" value="ws://127.0.0.1:18789" />
    </div>
    <div class="field">
      <label>Token</label>
      <input type="password" id="gw-token" placeholder="Gateway auth token" />
    </div>
    <div style="display:flex;gap:8px">
      <button id="gw-connect" style="flex:1;padding:8px;background:#22c55e;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px">Connect</button>
      <button id="gw-disconnect" style="padding:8px 16px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointer;font-size:13px;display:none">Disconnect</button>
    </div>
    <div id="gateway-status"></div>
    <details style="margin-top:12px;font-size:12px;color:#9ca3af">
      <summary style="cursor:pointer;color:#60a5fa;font-size:12px">üìñ How to connect</summary>
      <div style="margin-top:8px;line-height:1.6">
        <p style="margin:0 0 6px"><strong>1. Find your Gateway token:</strong></p>
        <code style="background:#1f1f1f;padding:2px 6px;border-radius:4px;font-size:11px">cat ~/.openclaw/openclaw.json | grep -A1 '"auth"'</code>
        <p style="margin:8px 0 6px"><strong>2. If connecting from GitHub Pages, allow the origin:</strong></p>
        <code style="background:#1f1f1f;padding:2px 6px;border-radius:4px;font-size:11px;word-break:break-all">openclaw config set gateway.controlUi.allowedOrigins '["https://frexida.github.io"]'</code>
        <p style="margin:8px 0 6px"><strong>3. Restart gateway:</strong></p>
        <code style="background:#1f1f1f;padding:2px 6px;border-radius:4px;font-size:11px">openclaw gateway restart</code>
        <p style="margin:8px 0 0;color:#6b7280">Default URL: <code>ws://127.0.0.1:18789</code> ¬∑ Paste token above and click Connect.</p>
      </div>
    </details>
  </div>

  <!-- Chat panel -->
  <div id="chat-panel">
    <div class="chat-header">
      <div class="chat-header-left">
        <span id="chat-agent-icon" class="chat-agent-icon">ü§ñ</span>
        <div class="chat-header-info">
          <span id="chat-agent-name">Agent Chat</span>
          <span id="chat-agent-status" class="chat-agent-status">offline</span>
        </div>
      </div>
      <button id="chat-panel-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button>
    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <div class="chat-input-area" id="chat-input-area">
      <textarea id="chat-input" placeholder="Type a message..." rows="1"></textarea>
      <button id="chat-send-btn" title="Send">
        <span id="chat-send-icon">‚û§</span>
        <span id="chat-send-spinner" style="display:none">‚è≥</span>
      </button>
    </div>
  </div>

  <!-- Export preview modal -->
  <div id="export-overlay"></div>
  <div id="export-modal">
    <h3>üì§ Export Preview <button id="export-modal-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button></h3>
    <div class="export-stats">
      <span>üë• Agents: <strong id="export-stat-agents">0</strong></span>
      <span>üîó Links: <strong id="export-stat-links">0</strong></span>
      <span>üìÅ Groups: <strong id="export-stat-groups">0</strong></span>
    </div>
    <div class="export-tabs">
      <button class="active" data-tab="config">‚öôÔ∏è OpenClaw Config</button>
      <button data-tab="full">üì¶ Full Export</button>
      <button data-tab="script">üñ•Ô∏è Setup Script</button>
      <button data-tab="diff" id="tab-diff" style="display:none">üîç Diff</button>
    </div>
    <pre id="export-preview"></pre>
    <div class="export-actions">
      <button class="btn-download" id="export-dl-current">‚¨áÔ∏è Download</button>
      <button class="btn-download" id="export-dl-all" style="background:#059669">‚¨áÔ∏è All Files</button>
      <button class="btn-copy" id="export-copy">üìã Copy</button>
      <button class="btn-download" id="export-apply-gw" style="background:#f59e0b;color:#000;display:none">‚ö° Apply to Gateway</button>
      <button class="btn-download" id="export-revert-gw" style="background:#dc2626;color:#fff;display:none">‚Ü©Ô∏è Revert</button>
      <button class="btn-download" id="export-history-gw" style="background:#6366f1;color:#fff;display:none">üìú History</button>
      <button class="btn-close" id="export-close">Close</button>
    </div>
  </div>

  <!-- Diff Preview Modal -->
  <div id="diff-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:600"></div>
  <div id="diff-modal">
    <h3>üîç Config Diff Preview <button id="diff-modal-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button></h3>
    <p id="diff-summary" style="color:#9ca3af;margin:0 0 8px;font-size:13px"></p>
    <pre id="diff-preview"></pre>
    <div class="export-actions">
      <button class="btn-download" id="diff-confirm-apply" style="background:#f59e0b;color:#000">‚úÖ Confirm Apply</button>
      <button class="btn-close" id="diff-cancel">Cancel</button>
    </div>
  </div>

  <!-- Config History modal -->
  <div id="history-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:610"></div>
  <div id="history-modal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #333;border-radius:12px;padding:24px;z-index:611;width:600px;max-width:90vw;max-height:80vh;overflow-y:auto;flex-direction:column">
    <h3 style="color:#e5e7eb;margin:0 0 12px;display:flex;justify-content:space-between;align-items:center">
      üìú Config History
      <button id="history-modal-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button>
    </h3>
    <p style="color:#9ca3af;font-size:13px;margin:0 0 12px">Previous configs saved before each Apply. Click to restore.</p>
    <div id="history-list" style="display:flex;flex-direction:column;gap:8px"></div>
  </div>

  <!-- Template modal -->
  <div id="template-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:499"></div>
  <div id="template-modal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #333;border-radius:12px;padding:24px;z-index:500;width:520px;max-width:90vw;max-height:80vh;overflow-y:auto">
    <h3 style="color:#e5e7eb;margin:0 0 16px;display:flex;justify-content:space-between;align-items:center">
      üìã Organization Templates
      <button id="template-modal-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button>
    </h3>
    <p style="color:#9ca3af;font-size:13px;margin:0 0 16px">Selecting a template will replace the current canvas.</p>
    <div style="display:flex;flex-direction:column;gap:12px">
      <button class="template-card" data-template="startup" style="text-align:left;padding:16px;background:#1f1f1f;border:1px solid #333;border-radius:8px;color:#e5e7eb;cursor:pointer;transition:border-color 150ms">
        <div style="font-size:15px;font-weight:bold;margin-bottom:4px">üöÄ Startup</div>
        <div style="font-size:12px;color:#9ca3af">CEO ‚Üí PM ‚Üí Dev√ó2. Lean team structure for fast-moving startups.</div>
        <div style="font-size:11px;color:#6b7280;margin-top:6px">4 agents / authority + communication</div>
      </button>
      <button class="template-card" data-template="hierarchy" style="text-align:left;padding:16px;background:#1f1f1f;border:1px solid #333;border-radius:8px;color:#e5e7eb;cursor:pointer;transition:border-color 150ms">
        <div style="font-size:15px;font-weight:bold;margin-bottom:4px">üè¢ Hierarchical</div>
        <div style="font-size:12px;color:#9ca3af">Director ‚Üí Manager√ó2 ‚Üí Member√ó4. Vertical structure for large projects.</div>
        <div style="font-size:11px;color:#6b7280;margin-top:6px">7 agents / authority + review</div>
      </button>
      <button class="template-card" data-template="flat" style="text-align:left;padding:16px;background:#1f1f1f;border:1px solid #333;border-radius:8px;color:#e5e7eb;cursor:pointer;transition:border-color 150ms">
        <div style="font-size:15px;font-weight:bold;margin-bottom:4px">ü§ù Flat</div>
        <div style="font-size:12px;color:#9ca3af">Lead + Member√ó3. Equal collaboration for small teams.</div>
        <div style="font-size:11px;color:#6b7280;margin-top:6px">4 agents / communication</div>
      </button>
    </div>
  </div>

  <!-- Task Characteristics Wizard -->
  <div id="wizard-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:509"></div>
  <div id="wizard-modal">
    <h3>üß© Task Characteristics Wizard <button id="wizard-modal-close" style="background:none;border:none;color:var(--text-tertiary);font-size:20px;cursor:pointer">‚úï</button></h3>
    <p class="wizard-subtitle">Choose the interdependence pattern that best fits your team's workflow.</p>
    <div class="wizard-cards">
      <button class="wizard-card" data-wizard="independent">
        <div class="wc-title">üîπ IndependentÔºàÂêÑËá™Áã¨Á´ãÔºâ</div>
        <div class="wc-desc">ÂêÑ„É°„É≥„Éê„Éº„ÅåÁã¨Á´ã„Åó„Å¶„Çø„Çπ„ÇØ„ÇíÈÅÇË°å„ÄÇ‰∏≠Â§Æ„ÅÆË™øÊï¥ÂΩπ„ÅåÁµêÊûú„ÇíÈõÜÁ¥Ñ„ÄÇ</div>
        <div class="wc-examples">‰æã: Á†îÁ©∂ÂÆ§„ÄÅ„Éï„É™„Éº„É©„É≥„Çπ„ÉÅ„Éº„É†</div>
        <div class="wc-preset">‚Üí Tree mode ¬∑ Unidirectional ¬∑ Hub-and-spoke layout</div>
      </button>
      <button class="wizard-card" data-wizard="sequential">
        <div class="wc-title">üî∏ SequentialÔºàÈ†ÜÂ∫èÂûãÔºâ</div>
        <div class="wc-desc">„Çø„Çπ„ÇØ„ÅåÈ†ÜÁï™„Å´Âºï„ÅçÁ∂ô„Åå„Çå„Çã„ÄÇÂâçÂ∑•Á®ã„ÅÆÂá∫Âäõ„ÅåÊ¨°Â∑•Á®ã„ÅÆÂÖ•Âäõ„ÄÇ</div>
        <div class="wc-examples">‰æã: CI/CD„Éë„Ç§„Éó„É©„Ç§„É≥„ÄÅË£ΩÈÄ†„É©„Ç§„É≥</div>
        <div class="wc-preset">‚Üí Tree mode (DAG) ¬∑ Unidirectional ¬∑ Linear chain layout</div>
      </button>
      <button class="wizard-card" data-wizard="reciprocal">
        <div class="wc-title">üî¥ ReciprocalÔºàÁõ∏‰∫íÂçîÂäõÔºâ</div>
        <div class="wc-desc">ÂØÜ„Å´„ÇÑ„ÇäÂèñ„Çä„Åó„Å™„Åå„ÇâÈÄ≤„ÇÅ„Çã„ÄÇ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„É´„Éº„Éó„ÅÇ„Çä„ÄÇ</div>
        <div class="wc-examples">‰æã: „Çπ„ÇØ„É©„É†„ÉÅ„Éº„É†„ÄÅÂÖ±ÂêåÁ†îÁ©∂</div>
        <div class="wc-preset">‚Üí Graph mode ¬∑ Bidirectional ¬∑ Mesh layout</div>
      </button>
    </div>
    <div class="wizard-footer">
      <span class="wizard-ref">Based on Thompson's (1967) task interdependence model</span>
      <div class="wizard-actions">
        <button id="wizard-cancel">Cancel</button>
        <button id="wizard-apply" disabled>‚ñ∂ Start with this pattern</button>
      </div>
    </div>
  </div>

  <div class="hints-overlay" id="hints-overlay" style="display:none;">
    <span class="hint-item"><span class="hint-key">Double-click</span> Edit agent</span>
    <span class="hint-item"><span class="hint-key">Drag</span> Connect nodes</span>
    <span class="hint-item"><span class="hint-key">Click</span> Change link type</span>
    <span class="hint-item" style="margin-left:12px;border-left:1px solid #444;padding-left:12px">
      <span style="color:#ef4444">‚îÅ‚îÅ‚ñ∂</span> Command
      <span style="color:#3b82f6;margin-left:8px">‚ïå‚ïå‚ñ∂</span> Comm
      <span style="color:#f59e0b;margin-left:8px">¬∑¬∑¬∑‚ñ∂</span> Review
    </span>
    <button class="hint-close" id="hints-close" title="Close">‚úï</button>
  </div>
  <!-- Timeline panel -->
  <div id="timeline-panel">
    <div class="tl-header">
      <div class="tl-header-left">üìã Timeline <span class="tl-count" id="tl-count">0</span></div>
      <button id="timeline-panel-close" style="background:none;border:none;color:#6b7280;font-size:20px;cursor:pointer">‚úï</button>
    </div>
    <div class="tl-filter-bar">
      <button class="tl-filter-btn active" id="tl-filter-all">All</button>
      <span id="tl-filter-agent-name" style="font-size:11px;color:#6b7280;display:none"></span>
    </div>
    <div class="tl-entries" id="tl-entries">
      <div class="tl-empty">No activity yet.<br>Connect to Gateway to see live messages.</div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script src={`${base}/drawflow.min.js`} is:inline></script>
  <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js" is:inline></script>
  <script src="https://cdn.jsdelivr.net/npm/pathfinding@0.4.18/visual/lib/pathfinding-browser.min.js" is:inline></script>
  <script src={`${base}/gateway-client.js`} is:inline></script>
  <script is:inline>
  (function() {
    'use strict';

    const STORAGE_KEY = 'agentflow_org';
    const MODELS = [
      'anthropic/claude-opus-4-6',
      'openai/gpt-5.3-codex',
      'anthropic/claude-sonnet-4',
      'google/gemini-2.5-pro'
    ];
    const LINK_TYPES = ['authority', 'communication', 'review'];
    const LINK_COLORS = { authority: '#ef4444', communication: '#3b82f6', review: '#f59e0b' };

    // --- Canvas structure mode ---
    let canvasMode = localStorage.getItem('agentflow-canvas-mode') || 'graph';
    function setCanvasMode(mode) {
      canvasMode = mode;
      localStorage.setItem('agentflow-canvas-mode', mode);
      document.getElementById('btn-mode-graph').classList.toggle('active', mode === 'graph');
      document.getElementById('btn-mode-tree').classList.toggle('active', mode === 'tree');
      try { if (org.canvas) org.canvas.mode = mode; else org.canvas = { mode }; scheduleSave(); } catch(e) { /* org not yet initialized */ }
    }
    document.getElementById('btn-mode-graph').addEventListener('click', () => setCanvasMode('graph'));
    document.getElementById('btn-mode-tree').addEventListener('click', () => setCanvasMode('tree'));
    // Apply initial mode from localStorage
    setCanvasMode(canvasMode);

    function hasCycle(links, nodeToAgent) {
      // Build adjacency from org.links
      const adj = {};
      for (const l of links) {
        if (!adj[l.source]) adj[l.source] = [];
        adj[l.source].push(l.target);
      }
      const visited = new Set(), stack = new Set();
      function dfs(n) {
        if (stack.has(n)) return true;
        if (visited.has(n)) return false;
        visited.add(n); stack.add(n);
        for (const nb of (adj[n] || [])) { if (dfs(nb)) return true; }
        stack.delete(n);
        return false;
      }
      for (const n of Object.keys(adj)) { if (dfs(n)) return true; }
      return false;
    }

    function hasMultipleParents(links, targetAgentId) {
      return links.filter(l => l.target === targetAgentId).length > 1;
    }
    const DEFAULT_ICONS = ['üëî', '‚öôÔ∏è', 'üî¨', 'üé®', 'üëÅÔ∏è', 'üß™', 'üìä', 'üõ°Ô∏è'];

    // --- Organization State ---
    let org = {
      id: crypto.randomUUID(),
      name: 'Untitled Organization',
      description: '',
      version: 'v1',
      agents: [],
      links: [],
      groups: [],
      canvas: { mode: canvasMode }
    };

    // nodeId (drawflow int) -> agentId mapping
    let nodeToAgent = {};
    // connectionId -> linkType
    let connectionTypes = {};

    // --- Drawflow init ---
    const container = document.getElementById('drawflow');
    const editor = new Drawflow(container);
    editor.reroute = false;
    editor.curvature = 0.5;
    editor.reroute_curvature_start_end = 0.5;
    editor.reroute_curvature = 0.5;
    editor.start();

    // --- Smart Routing: orthogonal paths with overlap prevention ---
    // Track connection indices per port for offset calculation
    const _portConnectionCount = {}; // key: "nodeId:port:direction" ‚Üí count
    const _connectionOffsets = {};   // key: "srcNode:srcPort:dstNode:dstPort" ‚Üí offset

    function _computeConnectionOffsets() {
      // Reset
      for (const k in _portConnectionCount) delete _portConnectionCount[k];
      for (const k in _connectionOffsets) delete _connectionOffsets[k];

      const data = editor.export()?.drawflow?.Home?.data;
      if (!data) return;

      // Count connections per output port
      const portGroups = {}; // "nodeId:outputClass" ‚Üí [{connKey, ...}]
      for (const [nodeId, node] of Object.entries(data)) {
        for (const [outClass, conns] of Object.entries(node.outputs || {})) {
          for (const conn of conns.connections || []) {
            const key = `${nodeId}:${outClass}`;
            if (!portGroups[key]) portGroups[key] = [];
            portGroups[key].push({ src: nodeId, dst: conn.node, srcPort: outClass, dstPort: conn.output });
          }
        }
      }

      // Assign offsets: spread connections from same port
      const OFFSET_STEP = 8;
      for (const [, group] of Object.entries(portGroups)) {
        if (group.length <= 1) continue;
        const half = (group.length - 1) / 2;
        group.forEach((c, i) => {
          _connectionOffsets[`${c.src}:${c.srcPort}:${c.dst}:${c.dstPort}`] = (i - half) * OFFSET_STEP;
        });
      }

      // Same for input ports
      const inGroups = {};
      for (const [nodeId, node] of Object.entries(data)) {
        for (const [outClass, conns] of Object.entries(node.outputs || {})) {
          for (const conn of conns.connections || []) {
            const key = `${conn.node}:${conn.output}`;
            if (!inGroups[key]) inGroups[key] = [];
            inGroups[key].push({ src: nodeId, dst: conn.node, srcPort: outClass, dstPort: conn.output });
          }
        }
      }
      for (const [, group] of Object.entries(inGroups)) {
        if (group.length <= 1) continue;
        const half = (group.length - 1) / 2;
        group.forEach((c, i) => {
          const k = `${c.src}:${c.srcPort}:${c.dst}:${c.dstPort}:in`;
          _connectionOffsets[k] = (i - half) * OFFSET_STEP;
        });
      }
    }

    // Override updateConnectionNodes to compute offsets before rendering
    const _origUpdateConnectionNodes = editor.updateConnectionNodes.bind(editor);
    editor.updateConnectionNodes = function(id) {
      _computeConnectionOffsets();
      return _origUpdateConnectionNodes(id);
    };

    // --- Pathfinding-based smart routing ---
    const CELL_SIZE = 20;
    const GRID_PADDING = 200;
    const _pathCache = {};
    let _pathCacheDirty = false;

    function _clearPathCache() { for (const k in _pathCache) delete _pathCache[k]; _pathCacheDirty = false; }

    function _buildPathfindingGrid(skipNodeIds) {
      const data = editor.export()?.drawflow?.Home?.data;
      if (!data) return null;

      // Compute canvas bounds from all nodes
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const nodeRects = [];
      for (const [nid, node] of Object.entries(data)) {
        const el = container.querySelector(`#node-${nid}`);
        const w = el ? el.offsetWidth : GRID_W;
        const h = el ? el.offsetHeight : GRID_H;
        const x = node.pos_x;
        const y = node.pos_y;
        nodeRects.push({ id: nid, x, y, w, h });
        if (x - GRID_PADDING < minX) minX = x - GRID_PADDING;
        if (y - GRID_PADDING < minY) minY = y - GRID_PADDING;
        if (x + w + GRID_PADDING > maxX) maxX = x + w + GRID_PADDING;
        if (y + h + GRID_PADDING > maxY) maxY = y + h + GRID_PADDING;
      }

      const gridW = Math.ceil((maxX - minX) / CELL_SIZE);
      const gridH = Math.ceil((maxY - minY) / CELL_SIZE);
      if (gridW <= 0 || gridH <= 0 || gridW > 500 || gridH > 500) return null;

      const grid = new PF.Grid(gridW, gridH);
      const margin = 10;
      const skipSet = new Set(skipNodeIds || []);

      for (const r of nodeRects) {
        if (skipSet.has(r.id)) continue;
        const cx1 = Math.max(0, Math.floor((r.x - margin - minX) / CELL_SIZE));
        const cy1 = Math.max(0, Math.floor((r.y - margin - minY) / CELL_SIZE));
        const cx2 = Math.min(gridW - 1, Math.ceil((r.x + r.w + margin - minX) / CELL_SIZE));
        const cy2 = Math.min(gridH - 1, Math.ceil((r.y + r.h + margin - minY) / CELL_SIZE));
        for (let gx = cx1; gx <= cx2; gx++) {
          for (let gy = cy1; gy <= cy2; gy++) {
            grid.setWalkableAt(gx, gy, false);
          }
        }
      }

      return { grid, minX, minY, gridW, gridH };
    }

    const _pfFinder = typeof PF !== 'undefined' ? new PF.AStarFinder({ allowDiagonal: false }) : null;

    editor.createCurvature = function(startX, startY, endX, endY, curvature, type) {
      // Fallback function
      const fallback = () => {
        const gap = 40;
        const midY = (startY + endY) / 2;
        return ` M ${startX} ${startY} L ${startX} ${midY} L ${endX} ${midY} L ${endX} ${endY}`;
      };

      if (!_pfFinder || typeof PF === 'undefined') return fallback();

      // Cache key
      const cacheKey = `${Math.round(startX)},${Math.round(startY)},${Math.round(endX)},${Math.round(endY)}`;
      if (_pathCache[cacheKey]) return _pathCache[cacheKey];

      // Find which nodes contain start/end points to skip them as obstacles
      const data = editor.export()?.drawflow?.Home?.data;
      const skipIds = [];
      if (data) {
        for (const [nid, node] of Object.entries(data)) {
          const el = container.querySelector(`#node-${nid}`);
          const w = el ? el.offsetWidth : GRID_W;
          const h = el ? el.offsetHeight : GRID_H;
          const nx = node.pos_x, ny = node.pos_y;
          if (startX >= nx - 20 && startX <= nx + w + 20 && startY >= ny - 20 && startY <= ny + h + 20) skipIds.push(nid);
          if (endX >= nx - 20 && endX <= nx + w + 20 && endY >= ny - 20 && endY <= ny + h + 20) skipIds.push(nid);
        }
      }

      const info = _buildPathfindingGrid(skipIds);
      if (!info) { const r = fallback(); _pathCache[cacheKey] = r; return r; }

      const { grid, minX, minY, gridW, gridH } = info;
      const sx = Math.max(0, Math.min(gridW - 1, Math.round((startX - minX) / CELL_SIZE)));
      const sy = Math.max(0, Math.min(gridH - 1, Math.round((startY - minY) / CELL_SIZE)));
      const ex = Math.max(0, Math.min(gridW - 1, Math.round((endX - minX) / CELL_SIZE)));
      const ey = Math.max(0, Math.min(gridH - 1, Math.round((endY - minY) / CELL_SIZE)));

      // Ensure start/end cells are walkable
      grid.setWalkableAt(sx, sy, true);
      grid.setWalkableAt(ex, ey, true);

      let path;
      try {
        path = _pfFinder.findPath(sx, sy, ex, ey, grid);
      } catch (e) {
        const r = fallback(); _pathCache[cacheKey] = r; return r;
      }

      if (!path || path.length < 2) { const r = fallback(); _pathCache[cacheKey] = r; return r; }

      // Compress path (remove collinear intermediate points)
      path = PF.Util.compressPath(path);

      // Convert grid coords back to canvas coords, use exact start/end
      let d = ` M ${startX} ${startY}`;
      for (let i = 1; i < path.length - 1; i++) {
        const px = path[i][0] * CELL_SIZE + minX;
        const py = path[i][1] * CELL_SIZE + minY;
        d += ` L ${px} ${py}`;
      }
      d += ` L ${endX} ${endY}`;

      _pathCache[cacheKey] = d;
      return d;
    };

    // After connections are rendered, apply offsets by adjusting SVG paths
    function _applyConnectionOffsets() {
      const data = editor.export()?.drawflow?.Home?.data;
      if (!data) return;

      for (const [nodeId, node] of Object.entries(data)) {
        for (const [outClass, conns] of Object.entries(node.outputs || {})) {
          for (const conn of conns.connections || []) {
            const outKey = `${nodeId}:${outClass}:${conn.node}:${conn.output}`;
            const inKey = outKey + ':in';
            const srcOff = _connectionOffsets[outKey] || 0;
            const dstOff = _connectionOffsets[inKey] || 0;

            if (srcOff === 0 && dstOff === 0) continue;

            // Find the SVG path for this connection
            const sel = `.connection.node_in_node-${conn.node}.node_out_node-${nodeId}.${outClass}.${conn.output} path`;
            const pathEl = container.querySelector(sel);
            if (!pathEl) continue;

            const d = pathEl.getAttribute('d');
            if (!d) continue;

            // Parse and offset: shift start X by srcOff, end X by dstOff
            // The path is a series of M/L commands
            const parts = d.trim().split(/\s+/);
            const newParts = [];
            let i = 0;
            let ptIndex = 0;
            const totalPoints = parts.filter(p => p === 'M' || p === 'L').length;

            while (i < parts.length) {
              const cmd = parts[i];
              if (cmd === 'M' || cmd === 'L') {
                newParts.push(cmd);
                i++;
                let x = parseFloat(parts[i]); i++;
                let y = parseFloat(parts[i]); i++;
                // First point: apply srcOff, last point: apply dstOff
                if (ptIndex === 0) x += srcOff;
                else if (ptIndex === totalPoints - 1) x += dstOff;
                newParts.push(x.toString(), y.toString());
                ptIndex++;
              } else {
                newParts.push(parts[i]);
                i++;
              }
            }
            pathEl.setAttribute('d', newParts.join(' '));
          }
        }
      }
    }

    // Rewrite paths for horizontal connections (output_2 ‚Üí input_2)
    function _rewriteHorizontalPaths() {
      const precanvas = editor.precanvas;
      const zoom = editor.zoom;
      const u = precanvas.clientWidth / (precanvas.clientWidth * zoom) || 0;
      const p = precanvas.clientHeight / (precanvas.clientHeight * zoom) || 0;

      // Find all connections using output_2 and input_2
      const hConns = container.querySelectorAll('.connection.output_2.input_2');
      hConns.forEach(connEl => {
        const pathEl = connEl.querySelector('path.main-path');
        if (!pathEl) return;

        // Extract node IDs from classes
        let outNodeId = '', inNodeId = '';
        connEl.classList.forEach(cls => {
          if (cls.startsWith('node_out_node-')) outNodeId = cls.replace('node_out_', '');
          if (cls.startsWith('node_in_node-')) inNodeId = cls.replace('node_in_', '');
        });
        if (!outNodeId || !inNodeId) return;

        // Get port elements
        const outNodeEl = container.querySelector('#' + outNodeId);
        const inNodeEl = container.querySelector('#' + inNodeId);
        if (!outNodeEl || !inNodeEl) return;

        const outPort = outNodeEl.querySelector('.output.output_2');
        const inPort = inNodeEl.querySelector('.input.input_2');
        if (!outPort || !inPort) return;

        // Calculate port positions (same as Drawflow does)
        const startX = outPort.offsetWidth / 2 + (outPort.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * u;
        const startY = outPort.offsetHeight / 2 + (outPort.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * p;
        const endX = inPort.offsetWidth / 2 + (inPort.getBoundingClientRect().x - precanvas.getBoundingClientRect().x) * u;
        const endY = inPort.offsetHeight / 2 + (inPort.getBoundingClientRect().y - precanvas.getBoundingClientRect().y) * p;

        // Generate horizontal step-line path
        const gap = 40;
        const dx = endX - startX;
        const dy = endY - startY;
        const absDy = Math.abs(dy);
        let d;

        if (dx > gap && absDy < 60) {
          const midX = (startX + endX) / 2;
          d = ` M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
        } else if (dx > gap) {
          const midX = startX + gap;
          d = ` M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
        } else {
          // Target is left or same ‚Äî detour around
          const sideDir = dy >= 0 ? 1 : -1;
          const sideOffset = sideDir * Math.max(80, absDy * 0.5 + 40);
          const rightOfStart = startX + gap;
          const leftOfEnd = endX - gap;
          d = ` M ${startX} ${startY} L ${rightOfStart} ${startY} L ${rightOfStart} ${startY + sideOffset} L ${leftOfEnd} ${startY + sideOffset} L ${leftOfEnd} ${endY} L ${endX} ${endY}`;
        }

        pathEl.setAttributeNS(null, 'd', d);
      });
    }

    // Hook into Drawflow's dispatch to apply offsets after connection updates
    let _nodeMovedTimer = null;
    function _debouncedRedraw() {
      _clearPathCache();
      _computeConnectionOffsets();
      // Force re-render all connections
      const data = editor.export()?.drawflow?.Home?.data;
      if (data) {
        for (const nid of Object.keys(data)) {
          _origUpdateConnectionNodes('node-' + nid);
        }
      }
      requestAnimationFrame(() => {
        _applyConnectionOffsets();
        _rewriteHorizontalPaths();
      });
    }

    const _origDispatch = editor.dispatch.bind(editor);
    editor.dispatch = function(event, details) {
      _origDispatch(event, details);
      if (event === 'connectionCreated' || event === 'connectionRemoved' || event === 'nodeRemoved') {
        _clearPathCache();
        _computeConnectionOffsets();
        requestAnimationFrame(() => {
          _applyConnectionOffsets();
          _rewriteHorizontalPaths();
        });
      } else if (event === 'nodeMoved') {
        if (_nodeMovedTimer) clearTimeout(_nodeMovedTimer);
        _nodeMovedTimer = setTimeout(_debouncedRedraw, 200);
      }
    };

    // --- Helpers ---
    function uid() { return 'a' + crypto.randomUUID().slice(0, 8); }

    function toast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2000);
    }

    function agentById(id) { return org.agents.find(a => a.id === id); }
    function nodeIdForAgent(agentId) {
      return Object.keys(nodeToAgent).find(k => nodeToAgent[k] === agentId);
    }

    function createAgentHTML(agent) {
      return `<div class="agent-card" data-agent-id="${agent.id}" style="position:relative">
        <div class="agent-status" id="status-${agent.id}" title="Not connected"></div>
        <div class="agent-header">
          <div class="agent-icon">${agent.icon || 'ü§ñ'}</div>
          <div class="agent-name">${agent.name}</div>
        </div>
        <div class="agent-role">${agent.role || '(no role)'}</div>
        <div class="agent-model">${(typeof agent.model === 'string' ? agent.model : agent.model?.primary || MODELS[0]).split('/').pop()}</div>
      </div>`;
    }

    function updateNodeHTML(agentId) {
      const agent = agentById(agentId);
      const nid = nodeIdForAgent(agentId);
      if (!agent || !nid) return;
      const nodeEl = container.querySelector(`#node-${nid}`);
      if (!nodeEl) return;
      const content = nodeEl.querySelector('.drawflow_content_node');
      if (content) content.innerHTML = createAgentHTML(agent);
    }

    // --- Group Overlays ---
    const GROUP_COLORS = [
      { bg: 'rgba(59,130,246,0.08)', border: 'rgba(59,130,246,0.35)', text: '#60a5fa' },
      { bg: 'rgba(16,185,129,0.08)', border: 'rgba(16,185,129,0.35)', text: '#34d399' },
      { bg: 'rgba(245,158,11,0.08)', border: 'rgba(245,158,11,0.35)', text: '#fbbf24' },
      { bg: 'rgba(168,85,247,0.08)', border: 'rgba(168,85,247,0.35)', text: '#c084fc' },
      { bg: 'rgba(239,68,68,0.08)', border: 'rgba(239,68,68,0.35)', text: '#f87171' },
    ];

    function renderGroupOverlays() {
      // Remove existing overlays
      container.querySelectorAll('.group-overlay').forEach(el => el.remove());

      const drawflowData = editor.export()?.drawflow?.Home?.data;
      if (!drawflowData) return;

      org.groups.forEach((group, gi) => {
        if (!group.agentIds || group.agentIds.length === 0) return;

        const color = GROUP_COLORS[gi % GROUP_COLORS.length];
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let found = 0;

        for (const agentId of group.agentIds) {
          const nodeId = nodeIdForAgent(agentId);
          if (!nodeId || !drawflowData[nodeId]) continue;
          const node = drawflowData[nodeId];
          const el = container.querySelector(`#node-${nodeId}`);
          const w = el ? el.offsetWidth : 200;
          const h = el ? el.offsetHeight : 100;
          minX = Math.min(minX, node.pos_x);
          minY = Math.min(minY, node.pos_y);
          maxX = Math.max(maxX, node.pos_x + w);
          maxY = Math.max(maxY, node.pos_y + h);
          found++;
        }

        if (found === 0) return;

        const pad = 24;
        const overlay = document.createElement('div');
        overlay.className = 'group-overlay';
        overlay.style.cssText = `
          position: absolute;
          left: ${minX - pad}px;
          top: ${minY - pad}px;
          width: ${maxX - minX + pad * 2}px;
          height: ${maxY - minY + pad * 2}px;
          background: ${color.bg};
          border: 1.5px dashed ${color.border};
          border-radius: 12px;
          pointer-events: none;
          z-index: 0;
        `;

        const label = document.createElement('div');
        label.style.cssText = `
          position: absolute;
          top: -10px;
          left: 12px;
          background: #0f0f0f;
          color: ${color.text};
          font-size: 11px;
          font-weight: bold;
          padding: 2px 8px;
          border-radius: 4px;
          border: 1px solid ${color.border};
        `;
        label.textContent = group.name;
        overlay.appendChild(label);

        // Insert into drawflow's inner container
        const inner = container.querySelector('.drawflow') || container;
        inner.appendChild(overlay);
      });
    }

    // Update overlays on various events
    let overlayTimer;
    function scheduleOverlayUpdate() {
      clearTimeout(overlayTimer);
      overlayTimer = setTimeout(renderGroupOverlays, 50);
    }

    // --- Add Agent ---
    function addAgent(agentData, x, y) {
      const agent = {
        id: agentData?.id || uid(),
        name: agentData?.name || `Agent ${org.agents.length + 1}`,
        role: agentData?.role || '',
        personality: agentData?.personality || '',
        icon: agentData?.icon || DEFAULT_ICONS[org.agents.length % DEFAULT_ICONS.length],
        model: agentData?.model || MODELS[0],
        systemPrompt: agentData?.systemPrompt || '',
        toolsProfile: agentData?.toolsProfile || '',
        memory: agentData?.memory || '',
      };
      org.agents.push(agent);

      const px = x ?? 100 + (org.agents.length % 4) * 260;
      const py = y ?? 80 + Math.floor(org.agents.length / 4) * 200;
      const nodeId = editor.addNode(
        agent.id, 2, 2, px, py, 'agent-node', { agentId: agent.id }, createAgentHTML(agent)
      );
      nodeToAgent[nodeId] = agent.id;
      scheduleSave();
      return agent;
    }

    document.getElementById('btn-add-agent').addEventListener('click', () => {
      addAgent();
    });

    // --- Double-click ‚Üí side panel ---
    let editingAgentId = null;
    const panel = document.getElementById('side-panel');

    // --- Grid Snap ---
    const GRID_W = 200, GRID_H = 100;
    function snapToGrid(x, y) {
      return { x: Math.round(x / GRID_W) * GRID_W, y: Math.round(y / GRID_H) * GRID_H };
    }
    // Snap to grid on drop only (realtime snap during drag fights with Drawflow's internal positioning)
    editor.on('nodeMoved', function(nodeId) {
      const nodeData = editor.drawflow.drawflow[editor.module].data[nodeId];
      if (!nodeData) return;
      const snapped = snapToGrid(nodeData.pos_x, nodeData.pos_y);
      if (snapped.x !== nodeData.pos_x || snapped.y !== nodeData.pos_y) {
        nodeData.pos_x = snapped.x;
        nodeData.pos_y = snapped.y;
        const el = container.querySelector('#node-' + nodeId);
        if (el) {
          el.style.left = snapped.x + 'px';
          el.style.top = snapped.y + 'px';
          editor.updateConnectionNodes('node-' + nodeId);
        }
      }
      // Re-route connections to optimal ports based on new position
      rerouteConnectionsForNode(nodeId);
      scheduleSave();
      scheduleOverlayUpdate();
    });

    function rerouteConnectionsForNode(nodeId) {
      const data = editor.drawflow.drawflow[editor.module].data;
      const node = data[nodeId];
      if (!node) return;
      const toReroute = [];

      // Check outgoing connections
      for (const [outClass, output] of Object.entries(node.outputs || {})) {
        for (const conn of (output.connections || [])) {
          const [bestOut, bestIn] = bestPorts(nodeId, conn.node);
          if (outClass !== bestOut || conn.output !== bestIn) {
            toReroute.push({ src: nodeId, tgt: conn.node, oldOut: outClass, oldIn: conn.output, newOut: bestOut, newIn: bestIn });
          }
        }
      }

      // Check incoming connections
      for (const [inClass, input] of Object.entries(node.inputs || {})) {
        for (const conn of (input.connections || [])) {
          const [bestOut, bestIn] = bestPorts(conn.node, nodeId);
          if (conn.input !== bestOut || inClass !== bestIn) {
            toReroute.push({ src: conn.node, tgt: nodeId, oldOut: conn.input, oldIn: inClass, newOut: bestOut, newIn: bestIn });
          }
        }
      }

      _rerouteInProgress = true;
      try {
        for (const r of toReroute) {
          try {
            editor.removeSingleConnection(r.src, r.tgt, r.oldOut, r.oldIn);
            editor.addConnection(r.src, r.tgt, r.newOut, r.newIn);
          } catch(e) {}
        }
      } finally {
        _rerouteInProgress = false;
      }
    }

    editor.on('nodeSelected', function(nodeId) {
      // single click - no action
    });

    container.addEventListener('dblclick', (e) => {
      const card = e.target.closest('.agent-card');
      if (!card) return;
      const agentId = card.dataset.agentId;
      openPanel(agentId);
    });

    function openPanel(agentId) {
      const agent = agentById(agentId);
      if (!agent) return;
      // Close other panels (mutually exclusive)
      const tlp = document.getElementById('timeline-panel');
      if (tlp) tlp.classList.remove('open');
      // Close chat panel
      const cp = document.getElementById('chat-panel');
      if (cp) cp.classList.remove('open');
      editingAgentId = agentId;
      document.getElementById('edit-icon').value = agent.icon || '';
      document.getElementById('edit-name').value = agent.name || '';
      document.getElementById('edit-role').value = agent.role || '';
      document.getElementById('edit-personality').value = agent.personality || '';
      document.getElementById('edit-model').value = agent.model || MODELS[0];
      document.getElementById('edit-prompt').value = agent.systemPrompt || '';
      document.getElementById('edit-tools').value = agent.toolsProfile || '';
      document.getElementById('edit-memory').value = agent.memory || '';
      panel.classList.add('open');
    }

    function closePanel() {
      panel.classList.remove('open');
      editingAgentId = null;
    }

    document.getElementById('panel-close').addEventListener('click', closePanel);

    // Live editing
    ['edit-icon', 'edit-name', 'edit-role', 'edit-personality', 'edit-model', 'edit-prompt', 'edit-tools', 'edit-memory'].forEach(id => {
      document.getElementById(id).addEventListener('input', () => {
        if (!editingAgentId) return;
        const agent = agentById(editingAgentId);
        if (!agent) return;
        agent.icon = document.getElementById('edit-icon').value;
        agent.name = document.getElementById('edit-name').value;
        agent.role = document.getElementById('edit-role').value;
        agent.personality = document.getElementById('edit-personality').value;
        agent.model = document.getElementById('edit-model').value;
        agent.systemPrompt = document.getElementById('edit-prompt').value;
        agent.toolsProfile = document.getElementById('edit-tools').value;
        agent.memory = document.getElementById('edit-memory').value;
        updateNodeHTML(editingAgentId);
        scheduleSave();
      });
    });

    // --- Delete agent from panel ---
    document.getElementById('btn-delete-agent').addEventListener('click', () => {
      if (!editingAgentId) return;
      const agent = agentById(editingAgentId);
      if (!confirm(`„Äå${agent?.name || editingAgentId}„Äç ‚Äî delete this agent?`)) return;
      const nid = nodeIdForAgent(editingAgentId);
      if (nid) editor.removeNodeId('node-' + nid);
      closePanel();
    });

    // --- 4-port auto-routing ---
    function bestPorts(srcId, tgtId, rawData) {
      const data = rawData || editor.drawflow.drawflow[editor.module].data;
      const src = data[srcId];
      const tgt = data[tgtId];
      if (!src || !tgt) return ['output_1', 'input_1'];
      // Get node centers (approximate width 200, height 120)
      const sw = 200, sh = 120;
      const srcCx = src.pos_x + sw / 2, srcCy = src.pos_y + sh / 2;
      const tgtCx = tgt.pos_x + sw / 2, tgtCy = tgt.pos_y + sh / 2;
      const dx = tgtCx - srcCx;
      const dy = tgtCy - srcCy;
      // Pick ports based on dominant direction
      if (Math.abs(dx) > Math.abs(dy)) {
        // Horizontal dominant
        if (dx > 0) return ['output_2', 'input_2']; // target is right: src right port ‚Üí tgt left port
        else return ['input_2', 'output_2']; // target is left: src left port ‚Üí tgt right port (reversed)
      } else {
        // Vertical dominant
        if (dy > 0) return ['output_1', 'input_1']; // target is below: src bottom ‚Üí tgt top
        else return ['input_1', 'output_1']; // target is above: src top ‚Üí tgt bottom (reversed)
      }
    }

    // --- Connection / Link management ---
    let _rerouteInProgress = false;
    editor.on('connectionCreated', function(info) {
      // Auto-reroute to optimal port pair based on node positions
      if (!_rerouteInProgress) {
        const [bestOut, bestIn] = bestPorts(info.output_id, info.input_id);
        if (info.output_class !== bestOut || info.input_class !== bestIn) {
          _rerouteInProgress = true;
          try {
            editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class);
            editor.addConnection(info.output_id, info.input_id, bestOut, bestIn);
          } finally {
            _rerouteInProgress = false;
          }
          return; // The re-added connection will trigger this handler again
        }
      }

      const srcAgentId = nodeToAgent[info.output_id];
      const tgtAgentId = nodeToAgent[info.input_id];
      if (!srcAgentId || !tgtAgentId) return;

      const linkId = uid();
      const newLink = {
        id: linkId,
        source: srcAgentId,
        target: tgtAgentId,
        type: 'authority',
        direction: 'unidirectional',
      };
      org.links.push(newLink);

      // Tree mode validations
      if (canvasMode === 'tree') {
        if (hasMultipleParents(org.links, tgtAgentId)) {
          org.links = org.links.filter(l => l.id !== linkId);
          // Remove from drawflow
          try { editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class); } catch(e) {}
          toast('‚ö†Ô∏è Tree mode: each node can have only one parent');
          return;
        }
        if (hasCycle(org.links, nodeToAgent)) {
          org.links = org.links.filter(l => l.id !== linkId);
          try { editor.removeSingleConnection(info.output_id, info.input_id, info.output_class, info.input_class); } catch(e) {}
          toast('‚ö†Ô∏è Tree mode: cycles are not allowed');
          return;
        }
      }

      // Store connection key -> link mapping
      const connKey = `${info.output_id}_${info.input_id}`;
      connectionTypes[connKey] = { linkId, type: 'authority', direction: 'unidirectional' };
      applyConnectionColor(info.output_id, info.input_id, 'authority');
      applyConnectionDirection(info.output_id, info.input_id, 'unidirectional');
      scheduleSave();
    });

    editor.on('connectionRemoved', function(info) {
      const connKey = `${info.output_id}_${info.input_id}`;
      const ct = connectionTypes[connKey];
      if (ct) {
        org.links = org.links.filter(l => l.id !== ct.linkId);
        delete connectionTypes[connKey];
      }
      scheduleSave();
    });

    editor.on('nodeRemoved', function(nodeId) {
      const agentId = nodeToAgent[nodeId];
      if (agentId) {
        org.agents = org.agents.filter(a => a.id !== agentId);
        org.links = org.links.filter(l => l.source !== agentId && l.target !== agentId);
        delete nodeToAgent[nodeId];
        if (editingAgentId === agentId) closePanel();
      }
      // Clean connectionTypes
      for (const key of Object.keys(connectionTypes)) {
        if (key.startsWith(nodeId + '_') || key.endsWith('_' + nodeId)) {
          delete connectionTypes[key];
        }
      }
      scheduleSave();
      scheduleOverlayUpdate();
    });

    // Track mouse-up on drawflow to catch node drags
    container.addEventListener('mouseup', scheduleOverlayUpdate);

    function applyConnectionColor(outId, inId, type) {
      setTimeout(() => {
        const connections = container.querySelectorAll('.connection');
        connections.forEach(conn => {
          const classes = conn.classList;
          const path = conn.querySelector('.main-path');
          if (!path) return;
          if (classes.contains(`node_out_node-${outId}`) && classes.contains(`node_in_node-${inId}`)) {
            conn.classList.remove('link-authority', 'link-communication', 'link-review');
            conn.classList.add('link-' + type);
            path.style.stroke = LINK_COLORS[type];
          }
        });
      }, 50);
    }

    function applyConnectionDirection(outId, inId, direction) {
      setTimeout(() => {
        const connections = container.querySelectorAll('.connection');
        connections.forEach(conn => {
          if (conn.classList.contains(`node_out_node-${outId}`) && conn.classList.contains(`node_in_node-${inId}`)) {
            conn.classList.toggle('link-bidirectional', direction === 'bidirectional');
          }
        });
      }, 50);
    }

    function applyAllConnectionColors() {
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        applyConnectionColor(outId, inId, ct.type);
        applyConnectionDirection(outId, inId, ct.direction || 'unidirectional');
      }
    }

    // Click on connection to cycle link type
    container.addEventListener('click', (e) => {
      const path = e.target.closest('.main-path');
      if (!path) return;
      const conn = path.closest('.connection');
      if (!conn) return;

      // Find which connection this is
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        if (conn.classList.contains(`node_out_node-${outId}`) && conn.classList.contains(`node_in_node-${inId}`)) {
          const idx = LINK_TYPES.indexOf(ct.type);
          const newType = LINK_TYPES[(idx + 1) % LINK_TYPES.length];
          ct.type = newType;
          const link = org.links.find(l => l.id === ct.linkId);
          if (link) link.type = newType;
          applyConnectionColor(outId, inId, newType);
          toast(`Link type: ${newType}`);
          scheduleSave();
          break;
        }
      }
    });

    // --- Link modal (double-click to edit) ---
    let editingConnKey = null;
    const linkModal = document.getElementById('link-modal');
    const linkOverlay = document.getElementById('link-modal-overlay');

    function openLinkModal(connKey) {
      const ct = connectionTypes[connKey];
      if (!ct) return;
      const link = org.links.find(l => l.id === ct.linkId);
      if (!link) return;
      editingConnKey = connKey;
      document.getElementById('link-type').value = link.type;
      document.getElementById('link-label').value = link.label || '';
      // Set direction toggle
      const dir = ct.direction || link.direction || 'unidirectional';
      document.querySelectorAll('#link-direction-toggle button').forEach(b => {
        const isActive = b.dataset.dir === dir;
        b.classList.toggle('active', isActive);
        b.style.background = isActive ? '#3b82f6' : '#333';
        b.style.borderColor = isActive ? '#3b82f6' : '#555';
      });
      linkModal.style.display = 'block';
      linkOverlay.style.display = 'block';
    }

    function closeLinkModal() {
      linkModal.style.display = 'none';
      linkOverlay.style.display = 'none';
      editingConnKey = null;
    }

    document.querySelectorAll('#link-direction-toggle button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#link-direction-toggle button').forEach(b => {
          const isActive = b === btn;
          b.classList.toggle('active', isActive);
          b.style.background = isActive ? '#3b82f6' : '#333';
          b.style.borderColor = isActive ? '#3b82f6' : '#555';
        });
      });
    });

    document.getElementById('link-modal-close').addEventListener('click', closeLinkModal);
    linkOverlay.addEventListener('click', closeLinkModal);

    document.getElementById('link-modal-save').addEventListener('click', () => {
      if (!editingConnKey) return;
      const ct = connectionTypes[editingConnKey];
      if (!ct) return;
      const link = org.links.find(l => l.id === ct.linkId);
      if (!link) return;
      const newType = document.getElementById('link-type').value;
      const newLabel = document.getElementById('link-label').value;
      const newDir = document.querySelector('#link-direction-toggle button.active')?.dataset.dir || 'unidirectional';
      link.type = newType;
      link.label = newLabel || undefined;
      link.direction = newDir;
      ct.type = newType;
      ct.direction = newDir;
      const [outId, inId] = editingConnKey.split('_');
      applyConnectionColor(outId, inId, newType);
      applyConnectionDirection(outId, inId, newDir);
      toast(`Link updated: ${newType} ${newDir === 'bidirectional' ? '‚Üî' : '‚Üí'}${newLabel ? ' ‚Äî ' + newLabel : ''}`);
      scheduleSave();
      closeLinkModal();
    });

    document.getElementById('link-modal-delete').addEventListener('click', () => {
      if (!editingConnKey) return;
      const [outId, inId] = editingConnKey.split('_');
      // Remove from drawflow
      const data = editor.export().drawflow.Home.data;
      const outNode = data[outId];
      if (outNode) {
        for (const [oKey, output] of Object.entries(outNode.outputs)) {
          output.connections = output.connections.filter(c => String(c.node) !== String(inId));
        }
      }
      const inNode = data[inId];
      if (inNode) {
        for (const [iKey, input] of Object.entries(inNode.inputs)) {
          input.connections = input.connections.filter(c => String(c.node) !== String(outId));
        }
      }
      editor.import({ drawflow: { Home: { data } } });
      // Clean up org state
      const ct = connectionTypes[editingConnKey];
      if (ct) org.links = org.links.filter(l => l.id !== ct.linkId);
      delete connectionTypes[editingConnKey];
      setTimeout(applyAllConnectionColors, 100);
      toast('Link deleted');
      scheduleSave();
      closeLinkModal();
    });

    container.addEventListener('dblclick', (e) => {
      const path = e.target.closest('.main-path');
      if (!path) return;
      const conn = path.closest('.connection');
      if (!conn) return;
      for (const [key, ct] of Object.entries(connectionTypes)) {
        const [outId, inId] = key.split('_');
        if (conn.classList.contains(`node_out_node-${outId}`) && conn.classList.contains(`node_in_node-${inId}`)) {
          openLinkModal(key);
          break;
        }
      }
    });

    // --- Group management ---
    const groupPanel = document.getElementById('group-panel');
    const groupList = document.getElementById('group-list');

    document.getElementById('btn-groups').addEventListener('click', () => {
      groupPanel.style.transform = groupPanel.style.transform === 'translateX(0px)' ? 'translateX(-100%)' : 'translateX(0px)';
      renderGroupList();
    });
    document.getElementById('group-panel-close').addEventListener('click', () => {
      groupPanel.style.transform = 'translateX(-100%)';
    });

    document.getElementById('btn-add-group').addEventListener('click', () => {
      const name = prompt('Group name:');
      if (!name) return;
      org.groups.push({ id: uid(), name, description: '', agentIds: [] });
      renderGroupList();
      scheduleSave();
    });

    function renderGroupList() {
      scheduleOverlayUpdate();
      groupList.innerHTML = '';
      for (const group of org.groups) {
        const div = document.createElement('div');
        div.style.cssText = 'background:#1a1a1a;border:1px solid #333;border-radius:8px;padding:12px;margin-bottom:10px';
        const members = group.agentIds.map(id => agentById(id)?.name || id).join(', ') || '(no members)';
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <strong style="color:#e5e7eb;font-size:14px">${group.name}</strong>
            <button data-delete-group="${group.id}" style="background:none;border:none;color:#dc2626;cursor:pointer;font-size:16px">‚úï</button>
          </div>
          <div style="font-size:12px;color:#6b7280;margin-bottom:8px">${members}</div>
          <div style="display:flex;flex-wrap:wrap;gap:4px">
            ${org.agents.map(a => {
              const inGroup = group.agentIds.includes(a.id);
              return `<button data-toggle-member="${group.id}:${a.id}" style="padding:3px 8px;font-size:11px;border-radius:4px;border:1px solid ${inGroup ? '#3b82f6' : '#333'};background:${inGroup ? '#1e3a5f' : '#1f1f1f'};color:${inGroup ? '#93c5fd' : '#6b7280'};cursor:pointer">${a.icon || 'ü§ñ'} ${a.name}</button>`;
            }).join('')}
          </div>
        `;
        groupList.appendChild(div);
      }
      // Event delegation
      groupList.querySelectorAll('[data-toggle-member]').forEach(btn => {
        btn.addEventListener('click', () => {
          const [gid, aid] = btn.dataset.toggleMember.split(':');
          const group = org.groups.find(g => g.id === gid);
          if (!group) return;
          const idx = group.agentIds.indexOf(aid);
          if (idx >= 0) group.agentIds.splice(idx, 1);
          else group.agentIds.push(aid);
          renderGroupList();
          scheduleSave();
        });
      });
      groupList.querySelectorAll('[data-delete-group]').forEach(btn => {
        btn.addEventListener('click', () => {
          const gid = btn.dataset.deleteGroup;
          org.groups = org.groups.filter(g => g.id !== gid);
          renderGroupList();
          scheduleSave();
        });
      });
    }

    // --- Auto Layout (dagre) ---
    document.getElementById('btn-auto-layout').addEventListener('click', () => {
      const data = editor.export().drawflow.Home.data;
      const nodeIds = Object.keys(data);
      if (nodeIds.length === 0) return;

      const g = new dagre.graphlib.Graph();
      g.setGraph({ rankdir: 'TB', nodesep: GRID_W, ranksep: GRID_H * 2 });
      g.setDefaultEdgeLabel(() => ({}));

      nodeIds.forEach(id => g.setNode(id, { width: 200, height: 100 }));
      nodeIds.forEach(id => {
        const node = data[id];
        Object.values(node.outputs || {}).forEach(output => {
          (output.connections || []).forEach(conn => g.setEdge(id, conn.node));
        });
      });

      dagre.layout(g);
      nodeIds.forEach(id => {
        const pos = g.node(id);
        const snapped = snapToGrid(pos.x - 100, pos.y - 50);
        data[id].pos_x = snapped.x;
        data[id].pos_y = snapped.y;
      });

      // Re-route connections to optimal ports based on new layout
      for (const id of nodeIds) {
        const node = data[id];
        const toMove = [];
        for (const [outClass, output] of Object.entries(node.outputs || {})) {
          for (const conn of (output.connections || [])) {
            const [bestOut, bestIn] = bestPorts(id, conn.node);
            if (outClass !== bestOut || conn.output !== bestIn) {
              toMove.push({ tgt: conn.node, oldOut: outClass, oldIn: conn.output, newOut: bestOut, newIn: bestIn });
            }
          }
        }
        for (const m of toMove) {
          // Move connection from old ports to new ports in data
          const oldOutConns = node.outputs[m.oldOut]?.connections || [];
          const idx = oldOutConns.findIndex(c => String(c.node) === String(m.tgt) && c.output === m.oldIn);
          if (idx >= 0) oldOutConns.splice(idx, 1);
          if (!node.outputs[m.newOut]) node.outputs[m.newOut] = { connections: [] };
          node.outputs[m.newOut].connections.push({ node: m.tgt, output: m.newIn });
          // Also fix input side
          const tgtNode = data[m.tgt];
          if (tgtNode) {
            const oldInConns = tgtNode.inputs[m.oldIn]?.connections || [];
            const iIdx = oldInConns.findIndex(c => String(c.node) === String(id) && c.input === m.oldOut);
            if (iIdx >= 0) oldInConns.splice(iIdx, 1);
            if (!tgtNode.inputs[m.newIn]) tgtNode.inputs[m.newIn] = { connections: [] };
            tgtNode.inputs[m.newIn].connections.push({ node: id, input: m.newOut });
          }
        }
      }

      editor.import({ drawflow: { Home: { data } } });
      // Re-apply colors after import
      setTimeout(() => { applyAllConnectionColors(); renderGroupOverlays(); }, 100);
    });

    // --- Export ---
    function validateOrg(org) {
      const warnings = [];
      const errors = [];
      if (org.agents.length === 0) errors.push('At least one agent is required');
      const names = org.agents.map(a => a.name);
      const dupes = names.filter((n, i) => names.indexOf(n) !== i);
      if (dupes.length) errors.push(`Duplicate names: ${[...new Set(dupes)].join(', ')}`);
      for (const a of org.agents) {
        if (!a.name || a.name.trim() === '') errors.push(`Agent has no name (${a.id})`);
        if (!a.role || a.role.trim() === '') warnings.push(`${a.name}: Role not set`);
        if (!a.systemPrompt || a.systemPrompt.trim() === '') warnings.push(`${a.name}: System Prompt is empty`);
      }
      // Check for orphan agents (no connections)
      const connectedIds = new Set(org.links.flatMap(l => [l.source, l.target]));
      const orphans = org.agents.filter(a => !connectedIds.has(a.id));
      if (orphans.length > 0 && org.agents.length > 1) {
        warnings.push(`No connections: ${orphans.map(a => a.name).join(', ')}`);
      }
      return { errors, warnings };
    }

    // --- Export preview modal ---
    let exportResult = null;
    let exportScript = '';
    let currentExportTab = 'config';

    const exportModal = document.getElementById('export-modal');
    const exportOverlay = document.getElementById('export-overlay');
    const exportPreview = document.getElementById('export-preview');

    function getExportContent(tab) {
      if (tab === 'config') return JSON.stringify(exportResult.config, null, 2);
      if (tab === 'full') return JSON.stringify(exportResult, null, 2);
      if (tab === 'script') return exportScript;
      return '';
    }

    let cachedDiffHtml = '';

    function showExportTab(tab) {
      currentExportTab = tab;
      document.querySelectorAll('.export-tabs button').forEach(b => {
        b.classList.toggle('active', b.dataset.tab === tab);
      });
      if (tab === 'diff') {
        exportPreview.innerHTML = cachedDiffHtml || '<span style="color:#8b949e">Loading diff...</span>';
      } else {
        exportPreview.innerHTML = '';
        exportPreview.textContent = getExportContent(tab);
      }
    }

    function openExportModal() {
      exportModal.style.display = 'flex';
      exportOverlay.style.display = 'block';
      document.getElementById('export-stat-agents').textContent = org.agents.length;
      document.getElementById('export-stat-links').textContent = org.links.length;
      document.getElementById('export-stat-groups').textContent = org.groups.length;
      // Show/hide Apply/Revert buttons
      const applyBtn = document.getElementById('export-apply-gw');
      const revertBtn = document.getElementById('export-revert-gw');
      const historyBtn = document.getElementById('export-history-gw');
      const gwConnected = window.gatewayClient?.connected;
      const history = JSON.parse(localStorage.getItem('agentflow-config-history') || '[]');
      applyBtn.style.display = gwConnected ? 'inline-block' : 'none';
      revertBtn.style.display = (gwConnected && history.length > 0) ? 'inline-block' : 'none';
      historyBtn.style.display = (gwConnected && history.length > 0) ? 'inline-block' : 'none';
      document.getElementById('tab-diff').style.display = gwConnected ? 'inline-block' : 'none';
      // Preload diff in background
      if (gwConnected) {
        window.gatewayClient.rpc('config.get', {}).then(res => {
          const currentConfig = res?.config || res || {};
          const newExport = exportResult.config;
          const merged = { ...currentConfig };
          merged.agents = {
            ...currentConfig.agents,
            defaults: newExport.agents?.defaults || currentConfig.agents?.defaults,
            list: newExport.agents?.list || []
          };
          const diffs = jsonDiff(currentConfig, merged);
          cachedDiffHtml = renderDiff(diffs);
          if (currentExportTab === 'diff') exportPreview.innerHTML = cachedDiffHtml;
        }).catch(() => { cachedDiffHtml = '<span style="color:#f85149">Failed to load diff</span>'; });
      }
      if (history.length > 0) {
        try {
          const t = new Date(history[0].timestamp).toLocaleString();
          revertBtn.textContent = `‚Ü©Ô∏è Revert (${t})`;
        } catch {}
      }
      showExportTab('config');
    }

    function closeExportModal() {
      exportModal.style.display = 'none';
      exportOverlay.style.display = 'none';
    }

    document.querySelectorAll('.export-tabs button').forEach(btn => {
      btn.addEventListener('click', () => showExportTab(btn.dataset.tab));
    });

    document.getElementById('export-modal-close').addEventListener('click', closeExportModal);
    document.getElementById('export-close').addEventListener('click', closeExportModal);
    exportOverlay.addEventListener('click', closeExportModal);

    document.getElementById('export-copy').addEventListener('click', () => {
      navigator.clipboard.writeText(getExportContent(currentExportTab)).then(() => toast('üìã Copied to clipboard'));
    });

    document.getElementById('export-dl-current').addEventListener('click', () => {
      const tab = currentExportTab;
      const name = org.name || 'agentflow';
      if (tab === 'config') {
        downloadBlob(new Blob([JSON.stringify(exportResult.config, null, 2)], { type: 'application/json' }), `${name}-openclaw.json`);
      } else if (tab === 'full') {
        downloadBlob(new Blob([JSON.stringify(exportResult, null, 2)], { type: 'application/json' }), `${name}-full-export.json`);
      } else {
        downloadBlob(new Blob([exportScript], { type: 'text/x-shellscript' }), `${name}-setup.sh`);
      }
      toast('‚¨áÔ∏è Download started');
    });

    document.getElementById('export-dl-all').addEventListener('click', () => {
      const name = org.name || 'agentflow';
      downloadBlob(new Blob([JSON.stringify(exportResult.config, null, 2)], { type: 'application/json' }), `${name}-openclaw.json`);
      downloadBlob(new Blob([JSON.stringify(exportResult, null, 2)], { type: 'application/json' }), `${name}-full-export.json`);
      downloadBlob(new Blob([exportScript], { type: 'text/x-shellscript' }), `${name}-setup.sh`);
      toast('Export complete (3 files)');
    });

    // --- Diff utility ---
    function jsonDiff(oldObj, newObj, path = '') {
      const lines = [];
      const allKeys = new Set([...Object.keys(oldObj || {}), ...Object.keys(newObj || {})]);
      for (const key of [...allKeys].sort()) {
        const fullPath = path ? `${path}.${key}` : key;
        const oldVal = oldObj?.[key];
        const newVal = newObj?.[key];
        if (JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;
        if (oldVal === undefined) {
          lines.push({ type: 'add', path: fullPath, value: newVal });
        } else if (newVal === undefined) {
          lines.push({ type: 'del', path: fullPath, value: oldVal });
        } else if (typeof oldVal === 'object' && typeof newVal === 'object' && !Array.isArray(oldVal) && !Array.isArray(newVal) && oldVal !== null && newVal !== null) {
          lines.push(...jsonDiff(oldVal, newVal, fullPath));
        } else {
          lines.push({ type: 'del', path: fullPath, value: oldVal });
          lines.push({ type: 'add', path: fullPath, value: newVal });
        }
      }
      return lines;
    }

    function renderDiff(diffs) {
      if (diffs.length === 0) return '<span style="color:#8b949e">No changes detected.</span>';
      return diffs.map(d => {
        const val = typeof d.value === 'object' ? JSON.stringify(d.value, null, 2) : String(d.value);
        const shortVal = val.length > 200 ? val.slice(0, 200) + '...' : val;
        if (d.type === 'add') return `<span class="diff-add">+ ${d.path}: ${shortVal}</span>`;
        if (d.type === 'del') return `<span class="diff-del">- ${d.path}: ${shortVal}</span>`;
        return '';
      }).join('\n');
    }

    let pendingApply = null; // { merged, baseHash, backup }

    document.getElementById('export-apply-gw').addEventListener('click', async () => {
      if (!window.gatewayClient?.connected) {
        toast('‚ùå Gateway not connected');
        return;
      }
      try {
        toast('Fetching current config for diff...');
        const currentResult = await window.gatewayClient.rpc('config.get', {});
        const currentConfig = currentResult?.config || currentResult || {};
        const baseHash = currentResult?.baseHash || currentResult?.hash || '';

        // Build merged config
        const newExport = exportResult.config;
        const merged = { ...currentConfig };
        merged.agents = {
          ...currentConfig.agents,
          defaults: newExport.agents?.defaults || currentConfig.agents?.defaults,
          list: newExport.agents?.list || []
        };

        // Compute diff
        const diffs = jsonDiff(currentConfig, merged);
        document.getElementById('diff-preview').innerHTML = renderDiff(diffs);
        document.getElementById('diff-summary').textContent = `${diffs.filter(d=>d.type==='add').length} additions, ${diffs.filter(d=>d.type==='del').length} removals`;

        // Store for confirm
        pendingApply = {
          merged,
          baseHash,
          backup: { config: currentConfig, baseHash, timestamp: new Date().toISOString() }
        };

        // Show diff modal
        document.getElementById('diff-overlay').style.display = 'block';
        document.getElementById('diff-modal').style.display = 'flex';
      } catch (err) {
        toast('‚ùå Failed to fetch config: ' + err.message);
      }
    });

    // Confirm apply after diff review
    document.getElementById('diff-confirm-apply').addEventListener('click', async () => {
      if (!pendingApply) return;
      try {
        // Save backup to history (keep last 10)
        const configHistory = JSON.parse(localStorage.getItem('agentflow-config-history') || '[]');
        configHistory.unshift(pendingApply.backup);
        if (configHistory.length > 10) configHistory.length = 10;
        localStorage.setItem('agentflow-config-history', JSON.stringify(configHistory));
        console.log(`[AgentFlow] Config backup saved (${configHistory.length} versions)`);

        toast('Applying merged config...');
        await window.gatewayClient.rpc('config.apply', { raw: JSON.stringify(pendingApply.merged, null, 2), baseHash: pendingApply.baseHash });
        toast('‚úÖ Config applied! Backup saved. Use Revert if needed.');
        pendingApply = null;
        document.getElementById('diff-overlay').style.display = 'none';
        document.getElementById('diff-modal').style.display = 'none';
        closeExportModal();
      } catch (err) {
        toast('‚ùå Apply failed: ' + err.message);
      }
    });

    // Close diff modal
    function closeDiffModal() {
      document.getElementById('diff-overlay').style.display = 'none';
      document.getElementById('diff-modal').style.display = 'none';
      pendingApply = null;
    }
    document.getElementById('diff-modal-close').addEventListener('click', closeDiffModal);
    document.getElementById('diff-cancel').addEventListener('click', closeDiffModal);
    document.getElementById('diff-overlay').addEventListener('click', closeDiffModal);

    document.getElementById('export-revert-gw').addEventListener('click', async () => {
      if (!window.gatewayClient?.connected) {
        toast('‚ùå Gateway not connected');
        return;
      }
      const configHistory = JSON.parse(localStorage.getItem('agentflow-config-history') || '[]');
      if (configHistory.length === 0) {
        toast('‚ùå No backup found');
        return;
      }
      const backup = configHistory[0];
      if (!confirm(`‚Ü©Ô∏è Revert to config from ${backup.timestamp}?\n\nThis will restore the previous config and restart the gateway.`)) return;
      try {
        const freshResult = await window.gatewayClient.rpc('config.get', {});
        const freshHash = freshResult?.baseHash || freshResult?.hash || '';
        await window.gatewayClient.rpc('config.apply', { raw: JSON.stringify(backup.config, null, 2), baseHash: freshHash });
        toast('‚úÖ Config reverted! Gateway restarting...');
        configHistory.shift();
        localStorage.setItem('agentflow-config-history', JSON.stringify(configHistory));
        closeExportModal();
      } catch (err) {
        toast('‚ùå Revert failed: ' + err.message);
      }
    });

    // --- Config History ---
    function openHistoryModal() {
      const history = JSON.parse(localStorage.getItem('agentflow-config-history') || '[]');
      const list = document.getElementById('history-list');
      if (history.length === 0) {
        list.innerHTML = '<p style="color:#6b7280">No history yet. Configs are saved before each Apply.</p>';
      } else {
        list.innerHTML = history.map((entry, i) => {
          const t = new Date(entry.timestamp).toLocaleString();
          const agentCount = entry.config?.agents?.list?.length || 0;
          return `<div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:#1f1f1f;border:1px solid #333;border-radius:8px">
            <div>
              <div style="color:#e5e7eb;font-size:14px">${i === 0 ? 'üîµ Latest' : `#${i + 1}`} ‚Äî ${t}</div>
              <div style="color:#9ca3af;font-size:12px">${agentCount} agents</div>
            </div>
            <div style="display:flex;gap:8px">
              <button class="history-restore" data-idx="${i}" style="padding:6px 12px;background:#22c55e;color:white;border:none;border-radius:6px;cursor:pointer;font-size:12px">Restore</button>
              <button class="history-view" data-idx="${i}" style="padding:6px 12px;background:#333;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer;font-size:12px">View</button>
            </div>
          </div>`;
        }).join('');
      }
      document.getElementById('history-overlay').style.display = 'block';
      document.getElementById('history-modal').style.display = 'flex';

      // Restore handler
      list.querySelectorAll('.history-restore').forEach(btn => {
        btn.addEventListener('click', async () => {
          const idx = parseInt(btn.dataset.idx);
          const entry = history[idx];
          if (!confirm(`Restore config from ${new Date(entry.timestamp).toLocaleString()}?\n\nThis will restart the gateway.`)) return;
          try {
            const freshResult = await window.gatewayClient.rpc('config.get', {});
            const freshHash = freshResult?.baseHash || freshResult?.hash || '';
            await window.gatewayClient.rpc('config.apply', { raw: JSON.stringify(entry.config, null, 2), baseHash: freshHash });
            toast('‚úÖ Config restored! Gateway restarting...');
            closeHistoryModal();
            closeExportModal();
          } catch (err) {
            toast('‚ùå Restore failed: ' + err.message);
          }
        });
      });

      // View handler
      list.querySelectorAll('.history-view').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = parseInt(btn.dataset.idx);
          const entry = history[idx];
          const w = window.open('', '_blank');
          w.document.write(`<pre style="background:#111;color:#e5e7eb;padding:20px;font-family:monospace">${JSON.stringify(entry.config, null, 2).replace(/</g, '&lt;')}</pre>`);
        });
      });
    }

    function closeHistoryModal() {
      document.getElementById('history-overlay').style.display = 'none';
      document.getElementById('history-modal').style.display = 'none';
    }
    document.getElementById('history-modal-close').addEventListener('click', closeHistoryModal);
    document.getElementById('history-overlay').addEventListener('click', closeHistoryModal);
    document.getElementById('export-history-gw').addEventListener('click', openHistoryModal);

    document.getElementById('btn-export').addEventListener('click', () => {
      const { errors, warnings } = validateOrg(org);
      if (errors.length > 0) {
        alert('‚ùå Export errors:\n' + errors.join('\n'));
        return;
      }
      if (warnings.length > 0) {
        if (!confirm('‚ö†Ô∏è Warnings:\n' + warnings.join('\n') + '\n\nContinue anyway?')) return;
      }
      exportResult = exportToOpenClaw(org);
      exportScript = generateSetupScript(org, exportResult);
      openExportModal();
    });

    function generateSetupScript(org, result) {
      function slugify(s) {
        return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') || 'unnamed';
      }
      const lines = [
        '#!/usr/bin/env bash',
        `# AgentFlow workspace setup ‚Äî ${org.name}`,
        `# Generated: ${new Date().toISOString()}`,
        'set -euo pipefail',
        '',
        'BASE_DIR="${1:-$HOME/.openclaw/workspace}"',
        'echo "Setting up agent workspaces in $BASE_DIR"',
        '',
      ];
      for (const agent of org.agents) {
        const slug = slugify(agent.name || agent.id);
        const files = result.meta.workspaceFiles[agent.id];
        if (!files) continue;
        lines.push(`# --- ${agent.name || agent.id} ---`);
        lines.push(`mkdir -p "$BASE_DIR/${slug}"`);
        for (const [fname, content] of Object.entries(files)) {
          lines.push(`cat > "$BASE_DIR/${slug}/${fname}" << 'AGENTFLOW_EOF'`);
          lines.push(content.trimEnd());
          lines.push('AGENTFLOW_EOF');
        }
        lines.push(`echo "  ‚úì ${agent.name || agent.id}"`);
        lines.push('');
      }
      lines.push('# Allow AgentFlow GitHub Pages to connect to your gateway');
      lines.push('echo "Adding AgentFlow to gateway allowedOrigins..."');
      lines.push('if command -v openclaw &>/dev/null; then');
      lines.push('  openclaw config set gateway.controlUi.allowedOrigins \'["https://frexida.github.io"]\' 2>/dev/null || true');
      lines.push('fi');
      lines.push('');
      lines.push('echo "Done. Run: openclaw gateway config.apply"');
      return lines.join('\n') + '\n';
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Inline export function v2 ‚Äî OpenClaw config schema compliant
    function exportToOpenClaw(org) {
      function slugify(s) {
        return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') || 'unnamed';
      }
      function findAgent(id) { return org.agents.find(a => a.id === id); }
      function agentName(id) { return findAgent(id)?.name || id; }

      const GUILD_PH = 'REPLACE_WITH_GUILD_ID';
      const chPH = (id) => 'REPLACE_WITH_CHANNEL_ID_FOR_' + slugify(id).toUpperCase();
      const primaryModel = (org.agents[0]?.model) || 'anthropic/claude-opus-4-6';
      const baseWorkspace = org._importedWorkspace || '/home/user/.openclaw/workspace';

      // agents.list
      const list = org.agents.map(agent => {
        const agentSlug = slugify(agent.name || agent.id);
        const authTargets = org.links
          .filter(l => l.source === agent.id && l.type === 'authority')
          .map(l => l.target);
        const entry = {
          id: agent.id,
          name: agent.name,
          workspace: baseWorkspace + '/' + agentSlug,
          identity: { name: agent.name },
        };
        if (agent.model && agent.model !== primaryModel) entry.model = agent.model;
        if (agent.icon) entry.identity.avatar = agent.icon;
        if (authTargets.length > 0) entry.subagents = { allowAgents: authTargets };
        if (agent.toolsProfile) entry.tools = { profile: agent.toolsProfile };
        return entry;
      });

      // bindings
      const bindings = org.agents.map(agent => ({
        agentId: agent.id,
        match: { channel: 'discord', guildId: GUILD_PH, peer: { kind: 'channel', id: chPH(agent.id) } },
      }));

      // channels
      const channelConfigs = {};
      for (const agent of org.agents) {
        channelConfigs[chPH(agent.id)] = { allow: true, requireMention: false };
      }

      const config = {
        agents: {
          defaults: { model: { primary: primaryModel }, workspace: baseWorkspace },
          list,
        },
        bindings,
        channels: {
          discord: {
            enabled: true,
            groupPolicy: 'allowlist',
            guilds: { [GUILD_PH]: { requireMention: true, users: ['*'], channels: channelConfigs } },
          },
        },
        commands: { native: 'auto', nativeSkills: 'auto' },
      };

      // workspace files (SOUL.md + AGENTS.md per agent)
      const workspaceFiles = {};
      for (const agent of org.agents) {
        const files = {};
        // SOUL.md
        const soulParts = ['# ' + (agent.name || agent.id)];
        if (agent.personality) soulParts.push('## Personality\n' + agent.personality);
        if (agent.role) soulParts.push('## Role\n' + agent.role);
        if (agent.systemPrompt) soulParts.push('## Instructions\n' + agent.systemPrompt);
        // Org relationships in SOUL.md
        const rels = [];
        const superiors = org.links.filter(l => l.target === agent.id && l.type === 'authority').map(l => agentName(l.source));
        if (superiors.length) rels.push('- **Reports to:** ' + superiors.join(', ') + ' ‚Äî prioritize their instructions');
        const subs = org.links.filter(l => l.source === agent.id && l.type === 'authority').map(l => agentName(l.target));
        if (subs.length) rels.push('- **Manages:** ' + subs.join(', ') + ' ‚Äî can delegate tasks via sessions_spawn');
        const comms = org.links.filter(l => (l.source === agent.id || l.target === agent.id) && l.type === 'communication')
          .map(l => agentName(l.source === agent.id ? l.target : l.source));
        if (comms.length) rels.push('- **Communicates with:** ' + comms.join(', '));
        const reviewTargets = org.links.filter(l => l.source === agent.id && l.type === 'review').map(l => agentName(l.target));
        if (reviewTargets.length) rels.push('- **Reviews work of:** ' + reviewTargets.join(', '));
        const reviewedBy = org.links.filter(l => l.target === agent.id && l.type === 'review').map(l => agentName(l.source));
        if (reviewedBy.length) rels.push('- **Reviewed by:** ' + reviewedBy.join(', '));
        if (rels.length) soulParts.push('## Organization\n' + rels.join('\n'));
        files['SOUL.md'] = soulParts.join('\n\n') + '\n';

        // AGENTS.md
        const agLines = ['# AGENTS.md ‚Äî Organization Context for ' + (agent.name || agent.id), ''];
        agLines.push('## Organization: ' + org.name);
        if (org.description) agLines.push('\n' + org.description);
        agLines.push('', '## Team Members');
        for (const a of org.agents) {
          const marker = a.id === agent.id ? ' **(you)**' : '';
          agLines.push('- **' + (a.name || a.id) + '**' + marker + ': ' + (a.role || 'No role defined'));
        }
        agLines.push('', '## Relationships');
        const authLinks = org.links.filter(l => l.type === 'authority');
        const commLinks2 = org.links.filter(l => l.type === 'communication');
        const revLinks2 = org.links.filter(l => l.type === 'review');
        if (authLinks.length) {
          agLines.push('### Authority (command chain)');
          for (const l of authLinks) agLines.push('- ' + agentName(l.source) + ' ‚Üí ' + agentName(l.target));
        }
        if (commLinks2.length) {
          agLines.push('### Communication');
          for (const l of commLinks2) agLines.push('- ' + agentName(l.source) + ' ‚Üî ' + agentName(l.target));
        }
        if (revLinks2.length) {
          agLines.push('### Review');
          for (const l of revLinks2) agLines.push('- ' + agentName(l.source) + ' reviews ' + agentName(l.target));
        }
        if (!authLinks.length && !commLinks2.length && !revLinks2.length) {
          agLines.push('- Flat structure (no links defined)');
        }
        if (org.groups.length) {
          agLines.push('', '## Groups');
          for (const g of org.groups) {
            agLines.push('- **' + g.name + '**: ' + g.agentIds.map(id => agentName(id)).join(', '));
          }
        }
        files['AGENTS.md'] = agLines.join('\n') + '\n';

        if (agent.memory) files['MEMORY.md'] = '# Initial Memory\n\n' + agent.memory + '\n';
        workspaceFiles[agent.id] = files;
      }

      return {
        config,
        meta: {
          exportedFrom: 'agentflow',
          version: 'v2',
          organizationId: org.id,
          organizationName: org.name,
          exportedAt: new Date().toISOString(),
          taskType: org.taskType || null,
          workspaceFiles,
          links: org.links.map(l => ({ source: l.source, target: l.target, type: l.type, ...(l.label && { label: l.label }) })),
        },
      };
    }

    // --- Save / Load ---
    let saveTimer = null;
    function scheduleSave() {
      clearTimeout(saveTimer);
      saveTimer = setTimeout(saveToStorage, 5000);
    }

    function saveToStorage() {
      const drawflowData = editor.export();
      const state = { org, nodeToAgent, connectionTypes, drawflow: drawflowData };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      updateOrgDisplay();
      toast('Saved');
    }

    function loadFromStorage() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      try {
        const state = JSON.parse(raw);
        org = state.org;
        if (org.canvas?.mode) setCanvasMode(org.canvas.mode);
        nodeToAgent = state.nodeToAgent || {};
        connectionTypes = state.connectionTypes || {};
        if (state.drawflow) {
          // Migrate old nodes from 1 input/1 output to 2/2
          const data = state.drawflow?.drawflow?.Home?.data;
          if (data) {
            for (const [nid, node] of Object.entries(data)) {
              if (!node.inputs.input_2) node.inputs.input_2 = { connections: [] };
              if (!node.outputs.output_2) node.outputs.output_2 = { connections: [] };
            }
            // Re-route existing connections to optimal ports
            for (const [nid, node] of Object.entries(data)) {
              const toMove = [];
              for (const [outClass, output] of Object.entries(node.outputs || {})) {
                for (const conn of (output.connections || [])) {
                  const [bestOut, bestIn] = bestPorts(nid, conn.node, data);
                  if (outClass !== bestOut || conn.output !== bestIn) {
                    toMove.push({ tgt: conn.node, oldOut: outClass, oldIn: conn.output, newOut: bestOut, newIn: bestIn });
                  }
                }
              }
              for (const m of toMove) {
                const oldOutConns = node.outputs[m.oldOut]?.connections || [];
                const idx = oldOutConns.findIndex(c => String(c.node) === String(m.tgt) && c.output === m.oldIn);
                if (idx >= 0) oldOutConns.splice(idx, 1);
                if (!node.outputs[m.newOut]) node.outputs[m.newOut] = { connections: [] };
                node.outputs[m.newOut].connections.push({ node: m.tgt, output: m.newIn });
                const tgtNode = data[m.tgt];
                if (tgtNode) {
                  const oldInConns = tgtNode.inputs[m.oldIn]?.connections || [];
                  const iIdx = oldInConns.findIndex(c => String(c.node) === String(nid) && c.input === m.oldOut);
                  if (iIdx >= 0) oldInConns.splice(iIdx, 1);
                  if (!tgtNode.inputs[m.newIn]) tgtNode.inputs[m.newIn] = { connections: [] };
                  tgtNode.inputs[m.newIn].connections.push({ node: nid, input: m.newOut });
                }
              }
            }
          }
          editor.import(state.drawflow);
          setTimeout(() => { applyAllConnectionColors(); renderGroupOverlays(); }, 100);
        }
        updateOrgDisplay();
        return true;
      } catch (e) {
        console.error('Failed to load:', e);
        return false;
      }
    }

    function updateOrgDisplay() {
      document.getElementById('org-name-display').textContent = org.name;
    }

    // --- Config Import ---
    document.getElementById('btn-import').addEventListener('click', async () => {
      // If gateway is connected, offer to import from gateway
      if (window.gatewayClient?.connected) {
        const choice = confirm('Import from connected Gateway?\n\nOK = Import from Gateway\nCancel = Import from file');
        if (choice) {
          try {
            toast('Fetching config from Gateway...');
            const result = await window.gatewayClient.rpc('config.get', {});
            if (result?.config) {
              importConfig(result.config);
              toast('Imported from Gateway ‚úì');
            } else if (result) {
              importConfig(result);
              toast('Imported from Gateway ‚úì');
            } else {
              toast('Gateway returned empty config');
            }
          } catch (err) {
            toast('Gateway import failed: ' + err.message);
          }
          return;
        }
      }
      document.getElementById('import-file').click();
    });

    document.getElementById('import-file').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const json = JSON.parse(ev.target.result);
          importConfig(json);
        } catch (err) {
          toast('Failed to parse JSON: ' + err.message);
        }
      };
      reader.readAsText(file);
      e.target.value = ''; // reset for re-import
    });

    function importConfig(config) {
      // Support both OpenClaw config and AgentFlow full export
      const agents = config.agents?.list || config.org?.agents || [];
      const isOpenClawConfig = !!config.agents?.list;
      const isAgentFlowExport = !!config.org;

      if (agents.length === 0) {
        toast('Agent not found');
        return;
      }

      if (org.agents.length > 0 && !confirm('Replace current organization? Import will overwrite existing data.')) return;

      // Clear current
      editor.clear();
      org.agents = [];
      org.links = [];
      org.groups = [];
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();

      if (isAgentFlowExport && config.org) {
        // AgentFlow full export ‚Äî restore directly
        org.name = config.org.name || 'Imported Org';
        org.description = config.org.description || '';
        for (const a of config.org.agents || []) {
          addAgent(a, null, null);
        }
        // Restore links
        for (const link of config.org.links || []) {
          const srcAgent = agentById(link.source);
          const tgtAgent = agentById(link.target);
          if (srcAgent && tgtAgent) {
            connectAgents(srcAgent, tgtAgent, link.type || 'authority', link.direction || 'unidirectional');
          }
        }
        // Restore groups
        org.groups = config.org.groups || [];
        // Restore canvas mode
        if (config.org.canvas?.mode) setCanvasMode(config.org.canvas.mode);

      } else if (isOpenClawConfig) {
        // OpenClaw config format
        org.name = 'OpenClaw Import';
        const bindings = config.bindings || [];
        const defaults = config.agents?.defaults || {};
        // Detect workspace base path from defaults or first agent
        const defaultWs = defaults.workspace || agents[0]?.workspace || '';
        if (defaultWs) org._importedWorkspace = defaultWs;

        for (const agentDef of agents) {
          const rawModel = agentDef.model || defaults.model || '';
          const model = typeof rawModel === 'string' ? rawModel : rawModel?.primary || '';
          const binding = bindings.find(b => b.agentId === agentDef.id);
          const channelInfo = binding ? `${binding.match?.channel || ''} ${binding.match?.peer?.id || ''}`.trim() : '';

          addAgent({
            id: agentDef.id,
            name: agentDef.identity?.name || agentDef.name || agentDef.id,
            role: agentDef.id,
            icon: agentDef.identity?.avatar || 'ü§ñ',
            model: model,
            personality: '',
            systemPrompt: channelInfo ? `Channel binding: ${channelInfo}` : '',
            toolsProfile: '',
            memory: '',
          }, null, null);
        }

        // Create authority links from subagents.allowAgents
        for (const agentDef of agents) {
          const allowAgents = agentDef.subagents?.allowAgents || [];
          const srcAgent = org.agents.find(a => a.id === agentDef.id);
          if (!srcAgent) continue;
          for (const subId of allowAgents) {
            const tgtAgent = org.agents.find(a => a.id === subId);
            if (tgtAgent) {
              connectAgents(srcAgent, tgtAgent, 'authority');
            }
          }
        }
      }

      // Auto-layout after import
      setTimeout(() => {
        document.getElementById('btn-auto-layout').click();
        renderGroupOverlays();
        updateOrgDisplay();
        scheduleSave();
        toast(`${org.agents.length} agents imported`);
      }, 100);
    }

    document.getElementById('btn-save').addEventListener('click', () => {
      clearTimeout(saveTimer);
      saveToStorage();
    });

    // --- New Organization ---
    document.getElementById('btn-new-org').addEventListener('click', () => {
      const name = prompt('Organization name:');
      if (!name) return;
      editor.clear();
      org = {
        id: crypto.randomUUID(),
        name,
        description: '',
        version: 'v1',
        agents: [],
        links: [],
        groups: [],
        canvas: { mode: canvasMode }
      };
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();
      updateOrgDisplay();
      saveToStorage();
    });

    // --- Clear ---
    document.getElementById('btn-clear').addEventListener('click', () => {
      if (!confirm('Delete all nodes?')) return;
      editor.clear();
      org.agents = [];
      org.links = [];
      org.groups = [];
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();
      scheduleSave();
    });

    // --- Templates ---
    const templateModal = document.getElementById('template-modal');
    const templateOverlay = document.getElementById('template-overlay');

    function openTemplateModal() {
      templateModal.style.display = 'block';
      templateOverlay.style.display = 'block';
    }
    function closeTemplateModal() {
      templateModal.style.display = 'none';
      templateOverlay.style.display = 'none';
    }

    document.getElementById('btn-templates').addEventListener('click', openTemplateModal);
    document.getElementById('template-modal-close').addEventListener('click', closeTemplateModal);
    templateOverlay.addEventListener('click', closeTemplateModal);

    function applyTemplate(name) {
      if (org.agents.length > 0 && !confirm('Replace current organization? Applying a template will overwrite existing data.')) return;

      editor.clear();
      org.agents = [];
      org.links = [];
      org.groups = [];
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();

      if (name === 'startup') {
        org.name = 'Startup Team';
        const ceo = addAgent({ name: 'CEO', role: 'Chief Executive', icon: 'üëë', model: MODELS[0], personality: 'Vision and strategy. Final decisions.' }, 350, 60);
        const pm = addAgent({ name: 'PM', role: 'Project Manager', icon: 'üëî', model: MODELS[0], personality: 'Sprint planning, progress tracking, task delegation.' }, 350, 240);
        const dev1 = addAgent({ name: 'Dev-1', role: 'Developer', icon: '‚öôÔ∏è', model: MODELS[1], personality: 'Frontend/backend implementation. Ships fast.' }, 180, 420);
        const dev2 = addAgent({ name: 'Dev-2', role: 'Developer', icon: 'üîß', model: MODELS[1], personality: 'Infrastructure, testing, deployment.' }, 520, 420);
        connectAgents(ceo, pm, 'authority');
        connectAgents(pm, dev1, 'authority');
        connectAgents(pm, dev2, 'authority');
        connectAgents(dev1, dev2, 'communication');
      } else if (name === 'hierarchy') {
        org.name = 'Hierarchical Org';
        const dir = addAgent({ name: 'Director', role: 'Director', icon: 'üéØ', model: MODELS[0], personality: 'Strategic oversight. Cross-team coordination.' }, 400, 40);
        const mgr1 = addAgent({ name: 'Manager-A', role: 'Team Lead', icon: 'üëî', model: MODELS[0], personality: 'Team A management. Sprint execution.' }, 200, 200);
        const mgr2 = addAgent({ name: 'Manager-B', role: 'Team Lead', icon: 'üëî', model: MODELS[0], personality: 'Team B management. Quality assurance.' }, 600, 200);
        const m1 = addAgent({ name: 'Member-1', role: 'Developer', icon: '‚öôÔ∏è', model: MODELS[1], personality: 'Core feature development.' }, 100, 380);
        const m2 = addAgent({ name: 'Member-2', role: 'Developer', icon: 'üîß', model: MODELS[1], personality: 'API and integrations.' }, 300, 380);
        const m3 = addAgent({ name: 'Member-3', role: 'Designer', icon: 'üé®', model: MODELS[2], personality: 'UI/UX design and prototyping.' }, 500, 380);
        const m4 = addAgent({ name: 'Member-4', role: 'QA', icon: 'üß™', model: MODELS[2], personality: 'Testing and quality assurance.' }, 700, 380);
        connectAgents(dir, mgr1, 'authority');
        connectAgents(dir, mgr2, 'authority');
        connectAgents(mgr1, m1, 'authority');
        connectAgents(mgr1, m2, 'authority');
        connectAgents(mgr2, m3, 'authority');
        connectAgents(mgr2, m4, 'authority');
        connectAgents(mgr1, mgr2, 'review');
      } else if (name === 'flat') {
        org.name = 'Flat Team';
        const lead = addAgent({ name: 'Lead', role: 'Tech Lead', icon: '‚≠ê', model: MODELS[0], personality: 'Coordination and technical guidance. First among equals.' }, 350, 80);
        const a = addAgent({ name: 'Agent-A', role: 'Generalist', icon: 'üü¢', model: MODELS[1], personality: 'Flexible. Picks up whatever is needed.' }, 100, 280);
        const b = addAgent({ name: 'Agent-B', role: 'Generalist', icon: 'üîµ', model: MODELS[1], personality: 'Research-oriented. Explores solutions.' }, 350, 280);
        const c = addAgent({ name: 'Agent-C', role: 'Generalist', icon: 'üü£', model: MODELS[2], personality: 'Detail-focused. Reviews and polishes.' }, 600, 280);
        connectAgents(lead, a, 'communication');
        connectAgents(lead, b, 'communication');
        connectAgents(lead, c, 'communication');
        connectAgents(a, b, 'communication');
        connectAgents(b, c, 'communication');
      }

      updateOrgDisplay();
      scheduleSave();
      closeTemplateModal();
      showToast(`Template "${org.name}" applied`);
    }

    // connectAgents needs to be accessible from templates
    function connectAgents(srcAgent, tgtAgent, linkType, direction) {
      const srcNodeId = Object.keys(nodeToAgent).find(k => nodeToAgent[k] === srcAgent.id);
      const tgtNodeId = Object.keys(nodeToAgent).find(k => nodeToAgent[k] === tgtAgent.id);
      if (!srcNodeId || !tgtNodeId) return;
      const [bestOut, bestIn] = bestPorts(srcNodeId, tgtNodeId);
      editor.addConnection(srcNodeId, tgtNodeId, bestOut, bestIn);
      const connKey = `${srcNodeId}_${tgtNodeId}`;
      const ct = connectionTypes[connKey];
      if (ct) {
        if (linkType !== 'authority') {
          ct.type = linkType;
          const link = org.links.find(l => l.id === ct.linkId);
          if (link) link.type = linkType;
          applyConnectionColor(srcNodeId, tgtNodeId, linkType);
        }
        const dir = direction || 'unidirectional';
        ct.direction = dir;
        const link = org.links.find(l => l.id === ct.linkId);
        if (link) link.direction = dir;
        applyConnectionDirection(srcNodeId, tgtNodeId, dir);
      }
    }

    document.querySelectorAll('.template-card').forEach(card => {
      card.addEventListener('click', () => applyTemplate(card.dataset.template));
      card.addEventListener('mouseenter', () => card.style.borderColor = '#3b82f6');
      card.addEventListener('mouseleave', () => card.style.borderColor = '#333');
    });

    // --- Task Characteristics Wizard ---
    const wizardModal = document.getElementById('wizard-modal');
    const wizardOverlay = document.getElementById('wizard-overlay');
    const wizardApply = document.getElementById('wizard-apply');
    let selectedWizard = null;

    function openWizardModal() {
      wizardModal.style.display = 'block';
      wizardOverlay.style.display = 'block';
      selectedWizard = null;
      wizardApply.disabled = true;
      document.querySelectorAll('.wizard-card').forEach(c => c.classList.remove('selected'));
    }
    function closeWizardModal() {
      wizardModal.style.display = 'none';
      wizardOverlay.style.display = 'none';
    }

    document.getElementById('btn-wizard').addEventListener('click', openWizardModal);
    document.getElementById('wizard-modal-close').addEventListener('click', closeWizardModal);
    document.getElementById('wizard-cancel').addEventListener('click', closeWizardModal);
    wizardOverlay.addEventListener('click', closeWizardModal);

    document.querySelectorAll('.wizard-card').forEach(card => {
      card.addEventListener('click', () => {
        document.querySelectorAll('.wizard-card').forEach(c => c.classList.remove('selected'));
        card.classList.add('selected');
        selectedWizard = card.dataset.wizard;
        wizardApply.disabled = false;
      });
    });

    wizardApply.addEventListener('click', () => {
      if (!selectedWizard) return;
      if (org.agents.length > 0 && !confirm('Replace current organization? The wizard will create a new structure.')) return;

      editor.clear();
      org.agents = [];
      org.links = [];
      org.groups = [];
      nodeToAgent = {};
      connectionTypes = {};
      closePanel();

      org.taskType = selectedWizard;

      if (selectedWizard === 'independent') {
        org.name = 'Independent Team';
        setCanvasMode('tree');
        const coordinator = addAgent({ name: 'Coordinator', role: 'Central coordinator ‚Äî collects and integrates results', icon: 'üéØ', model: MODELS[0], personality: 'Aggregates outputs from independent workers. Ensures alignment with overall goals.' }, 350, 60);
        const w1 = addAgent({ name: 'Worker-A', role: 'Independent contributor', icon: 'üîπ', model: MODELS[1], personality: 'Works autonomously. Reports results to coordinator.' }, 100, 280);
        const w2 = addAgent({ name: 'Worker-B', role: 'Independent contributor', icon: 'üîπ', model: MODELS[1], personality: 'Works autonomously. Reports results to coordinator.' }, 350, 280);
        const w3 = addAgent({ name: 'Worker-C', role: 'Independent contributor', icon: 'üîπ', model: MODELS[2], personality: 'Works autonomously. Reports results to coordinator.' }, 600, 280);
        connectAgents(coordinator, w1, 'authority');
        connectAgents(coordinator, w2, 'authority');
        connectAgents(coordinator, w3, 'authority');

      } else if (selectedWizard === 'sequential') {
        org.name = 'Sequential Pipeline';
        setCanvasMode('tree');
        const s1 = addAgent({ name: 'Stage-1', role: 'Input & requirements gathering', icon: 'üì•', model: MODELS[0], personality: 'Gathers initial inputs. Prepares structured output for next stage.' }, 350, 60);
        const s2 = addAgent({ name: 'Stage-2', role: 'Processing & transformation', icon: '‚öôÔ∏è', model: MODELS[1], personality: 'Processes input from Stage-1. Transforms and enriches data.' }, 350, 220);
        const s3 = addAgent({ name: 'Stage-3', role: 'Validation & quality check', icon: 'üîç', model: MODELS[2], personality: 'Validates output from Stage-2. Ensures quality standards.' }, 350, 380);
        const s4 = addAgent({ name: 'Stage-4', role: 'Output & delivery', icon: 'üì§', model: MODELS[1], personality: 'Final packaging and delivery of results.' }, 350, 540);
        connectAgents(s1, s2, 'authority');
        connectAgents(s2, s3, 'authority');
        connectAgents(s3, s4, 'authority');

      } else if (selectedWizard === 'reciprocal') {
        org.name = 'Reciprocal Team';
        setCanvasMode('graph');
        const a = addAgent({ name: 'Member-A', role: 'Cross-functional collaborator', icon: 'üî¥', model: MODELS[0], personality: 'Active collaborator. Gives and receives feedback continuously.' }, 200, 80);
        const b = addAgent({ name: 'Member-B', role: 'Cross-functional collaborator', icon: 'üü†', model: MODELS[1], personality: 'Active collaborator. Gives and receives feedback continuously.' }, 500, 80);
        const c = addAgent({ name: 'Member-C', role: 'Cross-functional collaborator', icon: 'üü°', model: MODELS[2], personality: 'Active collaborator. Gives and receives feedback continuously.' }, 200, 300);
        const d = addAgent({ name: 'Member-D', role: 'Cross-functional collaborator', icon: 'üü£', model: MODELS[0], personality: 'Active collaborator. Gives and receives feedback continuously.' }, 500, 300);
        connectAgents(a, b, 'communication', 'bidirectional');
        connectAgents(a, c, 'communication', 'bidirectional');
        connectAgents(b, d, 'communication', 'bidirectional');
        connectAgents(c, d, 'communication', 'bidirectional');
        connectAgents(a, d, 'communication', 'bidirectional');
        connectAgents(b, c, 'communication', 'bidirectional');
      }

      updateOrgDisplay();
      // Auto layout
      setTimeout(() => {
        document.getElementById('btn-auto-layout').click();
        scheduleSave();
        toast(`‚úÖ ${org.name} ‚Äî ${selectedWizard} pattern applied`);
      }, 100);

      closeWizardModal();
    });

    // --- Init: load from storage or create demo ---
    function createDemoOrg() {
      org.name = 'AgentFlow Team';

      // Agents positioned for a clear hierarchy
      const ceo = addAgent({ name: 'Alex', role: 'CEO / Owner', icon: 'üëë', model: MODELS[0], personality: 'Final decision maker. Vision-driven.' }, 400, 60);
      const pm = addAgent({ name: 'Jordan', role: 'Project Manager', icon: 'üëî', model: MODELS[0], personality: 'Strict progress tracking. 30-min report cycles.' }, 250, 240);
      const dev = addAgent({ name: 'Sam', role: 'Developer', icon: '‚öôÔ∏è', model: MODELS[1], personality: 'Fast, pragmatic. Ships code.' }, 100, 420);
      const research = addAgent({ name: 'Riley', role: 'Researcher', icon: 'üî¨', model: MODELS[2], personality: 'Data-driven analysis. Neutral perspective.' }, 400, 420);
      const critic = addAgent({ name: 'Morgan', role: 'Strategy / Critic', icon: 'üî•', model: MODELS[0], personality: 'Brutal honesty. Finds every flaw.' }, 600, 240);

      connectAgents(ceo, pm, 'authority');
      connectAgents(pm, dev, 'authority');
      connectAgents(pm, research, 'authority');
      connectAgents(ceo, critic, 'review');

      updateOrgDisplay();
      scheduleSave();
    }

    if (!loadFromStorage()) {
      createDemoOrg();
    }

    // --- Onboarding hints ---
    if (!localStorage.getItem('agentflow-hints-dismissed')) {
      document.getElementById('hints-overlay').style.display = 'flex';
    }
    document.getElementById('hints-close').addEventListener('click', () => {
      document.getElementById('hints-overlay').style.display = 'none';
      localStorage.setItem('agentflow-hints-dismissed', '1');
    });

    // ==============================================
    // --- Gateway Connection & Live Monitor ---
    // ==============================================
    const gw = new GatewayClient();
    window.gatewayClient = gw;
    const gwBtn = document.getElementById('btn-gateway');
    const gwModal = document.getElementById('gateway-modal');
    const gwOverlay = document.getElementById('gateway-overlay');
    const gwStatus = document.getElementById('gateway-status');
    const gwConnectBtn = document.getElementById('gw-connect');
    const gwDisconnectBtn = document.getElementById('gw-disconnect');
    const chatPanel = document.getElementById('chat-panel');
    const chatMessages = document.getElementById('chat-messages');

    // Restore saved gateway settings
    const savedGw = JSON.parse(localStorage.getItem('agentflow-gateway') || 'null');
    if (savedGw) {
      document.getElementById('gw-url').value = savedGw.url || 'ws://127.0.0.1:18789';
      document.getElementById('gw-token').value = savedGw.token || '';
    }

    function openGatewayModal() {
      gwModal.style.display = 'block';
      gwOverlay.style.display = 'block';
    }
    function closeGatewayModal() {
      gwModal.style.display = 'none';
      gwOverlay.style.display = 'none';
    }

    gwBtn.addEventListener('click', openGatewayModal);
    document.getElementById('gateway-modal-close').addEventListener('click', closeGatewayModal);
    gwOverlay.addEventListener('click', closeGatewayModal);

    function setGwStatus(text, type) {
      gwStatus.textContent = text;
      gwStatus.className = type || '';
    }

    function updateGatewayButton(connected) {
      if (connected) {
        gwBtn.textContent = 'üü¢ Live';
        gwBtn.style.background = 'rgba(34,197,94,0.15)';
        gwBtn.style.borderColor = '#22c55e';
        gwBtn.style.color = '#22c55e';
        gwConnectBtn.style.display = 'none';
        gwDisconnectBtn.style.display = 'block';
      } else {
        gwBtn.textContent = 'üîå Connect';
        gwBtn.style.background = '#1a1a2e';
        gwBtn.style.borderColor = '#333';
        gwBtn.style.color = '';
        gwConnectBtn.style.display = 'block';
        gwDisconnectBtn.style.display = 'none';
      }
    }

    gwConnectBtn.addEventListener('click', async () => {
      const url = document.getElementById('gw-url').value.trim();
      const token = document.getElementById('gw-token').value.trim();
      if (!url) { setGwStatus('URL is required', 'error'); return; }
      if (!token) { setGwStatus('Token is required', 'error'); return; }

      setGwStatus('Connecting...', '');
      gwConnectBtn.disabled = true;

      try {
        await gw.connect(url, token);
        localStorage.setItem('agentflow-gateway', JSON.stringify({ url, token }));
        setGwStatus('Connected ‚úì', 'ok');
        updateGatewayButton(true);
        gw.startPolling(5000);
        startConfigPolling();
        toast('üü¢ Gateway connected');
      } catch (e) {
        setGwStatus('Failed: ' + e.message, 'error');
      } finally {
        gwConnectBtn.disabled = false;
      }
    });

    gwDisconnectBtn.addEventListener('click', () => {
      gw.disconnect();
      stopConfigPolling();
      setGwStatus('Disconnected', '');
      updateGatewayButton(false);
      clearAllAgentStatus();
      toast('Disconnected from gateway');
    });

    gw.addEventListener('disconnected', () => {
      stopConfigPolling();
      updateGatewayButton(false);
      clearAllAgentStatus();
    });

    // ==============================================
    // --- Config Change Polling ---
    // ==============================================
    let configPollTimer = null;
    let configBaseHash = null;

    async function importConfigFromGateway() {
      try {
        const result = await gw.getConfig();
        const config = result?.config || result;
        if (config) {
          importConfig(config);
        }
      } catch (e) {
        console.warn('Config auto-import failed:', e.message);
      }
    }

    function showConfigToast(message) {
      let el = document.getElementById('config-toast');
      if (!el) {
        el = document.createElement('div');
        el.id = 'config-toast';
        el.style.cssText = 'position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:#16a34a;color:white;padding:10px 24px;border-radius:8px;font-size:13px;font-weight:500;z-index:999;opacity:0;transition:opacity 300ms;pointer-events:none;';
        document.body.appendChild(el);
      }
      el.textContent = message;
      el.style.opacity = '1';
      setTimeout(() => { el.style.opacity = '0'; }, 3000);
    }

    function startConfigPolling() {
      stopConfigPolling();
      configBaseHash = null;
      configPollTimer = setInterval(async () => {
        if (!gw.connected) return;
        try {
          const result = await gw.getConfig();
          const config = result?.config || result;
          const hash = config?.baseHash || config?.hash || null;
          if (hash && configBaseHash && hash !== configBaseHash) {
            configBaseHash = hash;
            importConfig(config);
            showConfigToast('‚úÖ Config updated automatically');
          } else if (hash) {
            configBaseHash = hash;
          }
        } catch {}
      }, 10000);
      // Initial hash capture
      gw.getConfig().then(result => {
        const config = result?.config || result;
        configBaseHash = config?.baseHash || config?.hash || null;
      }).catch(() => {});
    }

    function stopConfigPolling() {
      if (configPollTimer) {
        clearInterval(configPollTimer);
        configPollTimer = null;
      }
    }

    // ==============================================
    // --- Agent Activity Monitor ---
    // ==============================================
    // Tracks session activity per agent, detects new messages,
    // triggers pulse animations and status indicator updates.

    const activityState = {
      // agentId ‚Üí { lastMessageId, lastMessageTs, lastSeenTs, hasActiveSession }
      agents: {},
      previousSnapshot: {}, // sessionKey ‚Üí last message id/ts
      pollTimer: null,
    };

    function clearAllAgentStatus() {
      document.querySelectorAll('.agent-status').forEach(el => {
        el.className = 'agent-status';
        el.title = 'Not connected';
      });
      document.querySelectorAll('.agent-last-activity').forEach(el => el.remove());
      activityState.agents = {};
      activityState.previousSnapshot = {};
    }

    function matchSessionToAgent(session) {
      // Extract agent name from session key pattern: "agent:<name>-<n>:..."
      const sid = session.sessionKey || session.key || '';
      const sAgent = session.agentId || session.agent || '';

      for (const agent of org.agents) {
        // Direct agent ID match
        if (sAgent && (sAgent === agent.id || sAgent === agent.name)) return agent;
        if (sid.includes(agent.id)) return agent;

        // Match agent name in session key (e.g. "agent:pm-1:discord:...")
        const nameLower = agent.name.toLowerCase().replace(/\s+/g, '');
        if (nameLower && sid.toLowerCase().includes(nameLower)) return agent;

        // Try matching by name in session label
        const label = session.label || session.name || '';
        if (label && agent.name && label.toLowerCase().includes(agent.name.toLowerCase())) return agent;
      }
      return null;
    }

    function getSessionMessageFingerprint(session) {
      // Get a unique fingerprint for the latest message in this session
      const msgs = session.messages || session.recentMessages || [];
      if (msgs.length > 0) {
        const latest = msgs[msgs.length - 1] || msgs[0];
        return {
          id: latest.id || latest.messageId || null,
          ts: latest.timestamp || latest.ts || latest.createdAt || null,
          content: (typeof latest.content === 'string' ? latest.content : '')?.slice(0, 50),
        };
      }
      // Fallback: use session-level last activity
      return {
        id: null,
        ts: session.lastActivity || session.updatedAt || null,
        content: null,
      };
    }

    function triggerPulse(agentId, type) {
      // type: 'green' (new message) or 'blue' (thinking)
      const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
      if (!card) return;
      const cls = `pulse-${type}`;
      card.classList.remove('pulse-green', 'pulse-blue');
      // Force reflow to restart animation
      void card.offsetWidth;
      card.classList.add(cls);
      setTimeout(() => card.classList.remove(cls), 3000);
    }

    function updateAgentStatusIndicator(agentId, state) {
      const statusEl = document.getElementById(`status-${agentId}`);
      if (!statusEl) return;

      if (state === 'active') {
        statusEl.className = 'agent-status active';
        statusEl.title = '‚óè Active session';
      } else if (state === 'recent') {
        statusEl.className = 'agent-status recent';
        statusEl.title = '‚óè Recent activity (< 60s)';
      } else if (state === 'busy') {
        statusEl.className = 'agent-status busy';
        statusEl.title = '‚óè Processing...';
      } else {
        statusEl.className = 'agent-status idle';
        statusEl.title = '‚óã Idle';
      }
    }

    function updateLastActivityLabel(agentId, timestamp) {
      if (!timestamp) return;
      const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
      if (!card) return;
      let label = card.querySelector('.agent-last-activity');
      if (!label) {
        label = document.createElement('div');
        label.className = 'agent-last-activity';
        card.appendChild(label);
      }
      const d = new Date(timestamp);
      if (isNaN(d.getTime())) return;
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      label.textContent = `last: ${hh}:${mm}:${ss}`;
    }

    function processSessionsUpdate(sessions) {
      const now = Date.now();
      const agentSeen = new Set();

      for (const session of sessions) {
        const agent = matchSessionToAgent(session);
        if (!agent) continue;
        agentSeen.add(agent.id);

        const sessionKey = session.sessionKey || session.key || session.id || '';
        const fingerprint = getSessionMessageFingerprint(session);
        const prev = activityState.previousSnapshot[sessionKey];

        // Detect new message
        const isNew = prev && (
          (fingerprint.id && fingerprint.id !== prev.id) ||
          (fingerprint.ts && fingerprint.ts !== prev.ts) ||
          (fingerprint.content && fingerprint.content !== prev.content)
        );

        // Detect thinking/busy state
        const isBusy = session.busy || session.status === 'busy' || session.running;

        if (isNew) {
          triggerPulse(agent.id, 'green');
          activityState.agents[agent.id] = {
            lastMessageTs: fingerprint.ts || now,
            hasActiveSession: true,
          };
        } else if (isBusy) {
          triggerPulse(agent.id, 'blue');
        }

        // Update snapshot
        activityState.previousSnapshot[sessionKey] = fingerprint;

        // Track activity
        if (!activityState.agents[agent.id]) {
          activityState.agents[agent.id] = { lastMessageTs: null, hasActiveSession: false };
        }
        activityState.agents[agent.id].hasActiveSession = true;
        if (fingerprint.ts) {
          const ts = new Date(fingerprint.ts).getTime();
          if (!isNaN(ts)) {
            const existing = activityState.agents[agent.id].lastMessageTs;
            if (!existing || ts > new Date(existing).getTime()) {
              activityState.agents[agent.id].lastMessageTs = fingerprint.ts;
            }
          }
        }

        // Update status indicator
        if (isBusy) {
          updateAgentStatusIndicator(agent.id, 'busy');
        } else {
          const lastTs = activityState.agents[agent.id]?.lastMessageTs;
          const lastTime = lastTs ? new Date(lastTs).getTime() : 0;
          if (lastTime && (now - lastTime) < 60000) {
            updateAgentStatusIndicator(agent.id, 'active');
          } else if (lastTime) {
            updateAgentStatusIndicator(agent.id, 'recent');
          } else {
            updateAgentStatusIndicator(agent.id, 'active');
          }
        }

        // Update timestamp label
        updateLastActivityLabel(agent.id, activityState.agents[agent.id]?.lastMessageTs);
      }

      // Reset agents not seen in any session
      for (const agent of org.agents) {
        if (!agentSeen.has(agent.id)) {
          updateAgentStatusIndicator(agent.id, 'idle');
          if (activityState.agents[agent.id]) {
            activityState.agents[agent.id].hasActiveSession = false;
          }
        }
      }
    }

    gw.addEventListener('sessions-updated', (e) => {
      const sessions = e.detail || [];
      processSessionsUpdate(sessions);
    });

    // --- Chat panel (click agent while connected) ---
    let chatAgentId = null;
    let chatSessionKey = null;
    let chatPollTimer = null;
    let chatLastMessageId = null;
    let chatMessages_data = [];
    const chatInput = document.getElementById('chat-input');
    const chatSendBtn = document.getElementById('chat-send-btn');
    const chatInputArea = document.getElementById('chat-input-area');

    function findSessionsForAgent(agentId, sessions) {
      // Returns sessions matching agentId, sorted by priority:
      // 1. agent:{agentId}:main (highest)
      // 2. agent:{agentId}:* (non-subagent)
      // 3. other matches
      const results = [];
      for (const session of sessions) {
        const key = session.sessionKey || session.key || '';
        // Skip subagent sessions
        if (key.includes(':subagent:')) continue;
        // Check if session belongs to this agent
        const matched = matchSessionToAgent(session);
        if (matched && matched.id === agentId) {
          let priority = 3;
          if (key === `agent:${agentId}:main`) priority = 1;
          else if (key.startsWith(`agent:${agentId}:`)) priority = 2;
          results.push({ session, key, priority });
        }
      }
      results.sort((a, b) => a.priority - b.priority);
      return results;
    }

    async function findSessionKeyForAgent(agentId) {
      try {
        let allSessions = gw.sessions || [];
        try {
          const fresh = await gw.getSessions();
          allSessions = fresh || allSessions;
        } catch {}
        const matches = findSessionsForAgent(agentId, allSessions);
        if (matches.length > 0) {
          return { key: matches[0].key, allMatches: matches };
        }
      } catch {}
      return null;
    }

    async function openChatPanel(agentId) {
      const agent = agentById(agentId);
      // Close other panels
      panel.classList.remove('open');
      editingAgentId = null;
      const tlp = document.getElementById('timeline-panel');
      if (tlp) tlp.classList.remove('open');

      chatAgentId = agentId;
      chatSessionKey = null;
      chatLastMessageId = null;
      chatMessages_data = [];

      // Update header
      document.getElementById('chat-agent-icon').textContent = agent?.icon || 'ü§ñ';
      document.getElementById('chat-agent-name').textContent = agent?.name || 'Agent Chat';

      if (!gw.connected) {
        // Show not-connected state
        document.getElementById('chat-agent-status').textContent = 'offline';
        document.getElementById('chat-agent-status').className = 'chat-agent-status';
        chatMessages.innerHTML = `<div class="chat-not-connected">
          <div style="font-size:32px">üîå</div>
          <div class="chat-connect-hint">Connect to Gateway first</div>
          <button onclick="document.getElementById('btn-gateway').click()">Connect</button>
        </div>`;
        chatInputArea.style.display = 'none';
        chatPanel.classList.add('open');
        return;
      }

      chatInputArea.style.display = 'flex';
      chatPanel.classList.add('open');
      chatMessages.innerHTML = '<div style="text-align:center;color:#555;padding:20px">Finding session...</div>';

      // Find session key
      const sessionResult = await findSessionKeyForAgent(agentId);
      if (!sessionResult) {
        document.getElementById('chat-agent-status').textContent = 'no session';
        document.getElementById('chat-agent-status').className = 'chat-agent-status';
        const mainKey = `agent:${agentId}:main`;
        chatMessages.innerHTML = `<div class="chat-not-connected">
          <div style="font-size:32px">üí¨</div>
          <div class="chat-connect-hint">No active session for this agent</div>
          <button id="chat-start-new" style="padding:8px 16px;background:var(--accent-blue);color:white;border:none;border-radius:var(--radius-md);cursor:pointer;font-size:13px">Start a new conversation</button>
        </div>`;
        chatInputArea.style.display = 'flex';
        chatSessionKey = mainKey;
        document.getElementById('chat-start-new')?.addEventListener('click', () => {
          chatInput.value = chatInput.value || 'Hello!';
          sendChatMessage();
        });
        return;
      }
      chatSessionKey = sessionResult.key;

      // Show session selector if multiple matches
      if (sessionResult.allMatches.length > 1) {
        const selectorHtml = sessionResult.allMatches.map(m =>
          `<option value="${escapeHtml(m.key)}" ${m.key === chatSessionKey ? 'selected' : ''}>${escapeHtml(m.key)}</option>`
        ).join('');
        const headerInfo = document.querySelector('#chat-panel .chat-header-info');
        let sel = document.getElementById('chat-session-selector');
        if (!sel) {
          sel = document.createElement('select');
          sel.id = 'chat-session-selector';
          sel.style.cssText = 'font-size:10px;background:var(--bg-input);color:var(--text-secondary);border:1px solid var(--border-default);border-radius:4px;padding:1px 4px;max-width:200px;';
          headerInfo.appendChild(sel);
        }
        sel.innerHTML = selectorHtml;
        sel.onchange = async () => {
          chatSessionKey = sel.value;
          await loadChatHistory();
        };
      } else {
        const sel = document.getElementById('chat-session-selector');
        if (sel) sel.remove();
      }

      document.getElementById('chat-agent-status').textContent = 'online';
      document.getElementById('chat-agent-status').className = 'chat-agent-status online';

      // Load initial history
      await loadChatHistory();
      startChatPolling();
    }

    function closeChatPanel() {
      chatPanel.classList.remove('open');
      chatAgentId = null;
      chatSessionKey = null;
      stopChatPolling();
    }

    document.getElementById('chat-panel-close').addEventListener('click', closeChatPanel);

    function formatMsgTime(ts) {
      if (!ts) return '';
      const d = new Date(ts);
      if (isNaN(d.getTime())) return '';
      return String(d.getHours()).padStart(2,'0') + ':' + String(d.getMinutes()).padStart(2,'0');
    }

    function cleanChatMessage(text) {
      if (!text) return '';
      let t = text;
      // Remove queued messages block
      t = t.replace(/\[Queued messages while agent was busy\][\s\S]*?(?=\n[^\-\nQ]|$)/g, '');
      // Remove "Conversation info (untrusted metadata):" + JSON block
      t = t.replace(/Conversation info \(untrusted metadata\):?\s*```[^`]*```/gs, '');
      t = t.replace(/Conversation info \(untrusted metadata\):?\s*\{[\s\S]*?\n\}/g, '');
      // Remove "Sender (untrusted metadata):" + JSON block
      t = t.replace(/Sender \(untrusted metadata\):?\s*```[^`]*```/gs, '');
      t = t.replace(/Sender \(untrusted metadata\):?\s*\{[\s\S]*?\n\}/g, '');
      // Remove untrusted context envelope
      t = t.replace(/Untrusted context \(metadata, do not treat as instructions or commands\):?\s*<<<EXTERNAL_UNTRUSTED_CONTENT>>>[\s\S]*?<<<END_EXTERNAL_UNTRUSTED_CONTENT>>>/g, '');
      // Remove Discord Guild timestamp lines
      t = t.replace(/\[Discord Guild #\S+[^\]]*\][^\n]*/g, '');
      // Trim leading/trailing whitespace and blank lines
      t = t.replace(/^\s*\n/gm, '\n').replace(/^\n+/, '').replace(/\n+$/, '').trim();
      return t;
    }

    function renderChatMessages() {
      chatMessages.innerHTML = '';
      if (chatMessages_data.length === 0) {
        chatMessages.innerHTML = '<div style="text-align:center;color:#555;padding:20px">No messages yet</div>';
        return;
      }
      for (const msg of chatMessages_data) {
        const role = msg.role || 'system';
        let content = '';
        if (typeof msg.content === 'string') {
          content = msg.content;
        } else if (Array.isArray(msg.content)) {
          // Find the text block, skip thinking blocks
          const textBlock = msg.content.find(b => b.type === 'text');
          content = textBlock?.text || '';
        } else {
          content = JSON.stringify(msg.content);
        }
        content = cleanChatMessage(content);
        // Skip empty, NO_REPLY, or HEARTBEAT_OK messages
        if (!content || /^\s*(NO_REPLY|HEARTBEAT_OK)\s*$/.test(content)) continue;
        const div = document.createElement('div');
        div.className = `chat-msg ${role}`;
        const ts = formatMsgTime(msg.timestamp || msg.ts || msg.createdAt);
        div.innerHTML = `${escapeHtml(content)}${ts ? `<span class="msg-ts">${ts}</span>` : ''}`;
        chatMessages.appendChild(div);
      }
      if (chatMessages.children.length === 0) {
        chatMessages.innerHTML = '<div style="text-align:center;color:#555;padding:20px">No messages yet</div>';
      }
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    async function loadChatHistory() {
      if (!chatSessionKey) return;
      chatMessages.innerHTML = '<div style="text-align:center;color:#555;padding:20px">Loading...</div>';
      try {
        const history = await gw.getChatHistory(chatSessionKey, 20);
        const msgs = history?.messages || history || [];
        chatMessages_data = Array.isArray(msgs) ? msgs : [];
        if (chatMessages_data.length > 0) {
          const last = chatMessages_data[chatMessages_data.length - 1];
          chatLastMessageId = last.id || last.messageId || null;
        }
        renderChatMessages();
      } catch (e) {
        chatMessages.innerHTML = `<div style="text-align:center;color:#ef4444;padding:20px">Error: ${e.message}</div>`;
      }
    }

    async function pollChatMessages() {
      if (!chatSessionKey || !gw.connected) return;
      try {
        const history = await gw.getChatHistory(chatSessionKey, 20);
        const msgs = history?.messages || history || [];
        if (!Array.isArray(msgs) || msgs.length === 0) return;
        // Detect changes by comparing last message timestamp and count
        const lastNew = msgs[msgs.length - 1];
        const newTs = lastNew.timestamp || lastNew.ts || 0;
        const oldLast = chatMessages_data.length > 0 ? chatMessages_data[chatMessages_data.length - 1] : null;
        const oldTs = oldLast ? (oldLast.timestamp || oldLast.ts || 0) : 0;
        if (msgs.length !== chatMessages_data.length || newTs !== oldTs) {
          chatMessages_data = msgs;
          renderChatMessages();
        }
      } catch {}
    }

    function startChatPolling() {
      stopChatPolling();
      chatPollTimer = setInterval(pollChatMessages, 3000);
    }

    function stopChatPolling() {
      if (chatPollTimer) {
        clearInterval(chatPollTimer);
        chatPollTimer = null;
      }
    }

    // Send message
    async function sendChatMessage() {
      const text = chatInput.value.trim();
      if (!text || !chatSessionKey || !gw.connected) return;

      chatSendBtn.disabled = true;
      document.getElementById('chat-send-icon').style.display = 'none';
      document.getElementById('chat-send-spinner').style.display = 'inline';

      // Optimistic add
      chatMessages_data.push({ role: 'user', content: text, timestamp: new Date().toISOString() });
      renderChatMessages();
      chatInput.value = '';
      chatInput.style.height = 'auto';

      try {
        await gw.sendMessage(chatSessionKey, text);
        // Poll immediately to get response
        setTimeout(pollChatMessages, 500);
      } catch (e) {
        chatMessages_data.push({ role: 'system', content: `Send failed: ${e.message}` });
        renderChatMessages();
      } finally {
        chatSendBtn.disabled = false;
        document.getElementById('chat-send-icon').style.display = 'inline';
        document.getElementById('chat-send-spinner').style.display = 'none';
      }
    }

    chatSendBtn.addEventListener('click', sendChatMessage);
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendChatMessage();
      }
    });

    // Auto-resize textarea
    chatInput.addEventListener('input', () => {
      chatInput.style.height = 'auto';
      chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
    });

    function escapeHtml(str) {
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // Agent card click ‚Üí open chat when gateway connected, timeline filter
    container.addEventListener('click', (e) => {
      const card = e.target.closest('.agent-card');
      if (!card) return;
      // Don't interfere with connection path clicks
      if (e.target.closest('.main-path') || e.target.closest('.connection')) return;
      const agentId = card.dataset.agentId;
      if (!agentId || e.detail >= 2) return; // skip double-clicks
      // Open chat (works both connected and not)
      openChatPanel(agentId);
      // Also filter timeline if open
      if (timelinePanel.classList.contains('open')) {
        timelineFilterAgent = agentId;
        renderTimeline();
      }
    });

    // ==============================================
    // --- Timeline Panel ---
    // ==============================================
    const timelinePanel = document.getElementById('timeline-panel');
    const tlEntries = document.getElementById('tl-entries');
    const tlCount = document.getElementById('tl-count');
    const TIMELINE_MAX = 50;
    const AGENT_COLORS = ['#60a5fa','#f87171','#34d399','#fbbf24','#c084fc','#fb923c','#22d3ee','#a78bfa','#f472b6','#4ade80'];
    let timelineData = []; // { ts, agentId, agentName, agentIcon, message, color }
    let timelineFilterAgent = null;
    let timelineSeenKeys = new Set();

    function getAgentColor(agentId) {
      const idx = org.agents.findIndex(a => a.id === agentId);
      return AGENT_COLORS[idx >= 0 ? idx % AGENT_COLORS.length : 0];
    }

    function openTimelinePanel() {
      // Close edit panel if open
      panel.classList.remove('open');
      editingAgentId = null;
      closeChatPanel();
      timelinePanel.classList.add('open');
    }
    function closeTimelinePanel() {
      timelinePanel.classList.remove('open');
    }

    document.getElementById('btn-timeline').addEventListener('click', () => {
      if (timelinePanel.classList.contains('open')) {
        closeTimelinePanel();
      } else {
        openTimelinePanel();
      }
    });
    document.getElementById('timeline-panel-close').addEventListener('click', closeTimelinePanel);
    document.getElementById('tl-filter-all').addEventListener('click', () => {
      timelineFilterAgent = null;
      renderTimeline();
    });

    // Close timeline when opening edit panel
    const _origOpenPanel = openPanel;
    // We patch openPanel inline ‚Äî it's already a function, re-wrap:
    const __openPanel = openPanel;

    function renderTimeline() {
      const filtered = timelineFilterAgent
        ? timelineData.filter(e => e.agentId === timelineFilterAgent)
        : timelineData;

      // Update filter UI
      const filterAllBtn = document.getElementById('tl-filter-all');
      const filterLabel = document.getElementById('tl-filter-agent-name');
      filterAllBtn.classList.toggle('active', !timelineFilterAgent);
      if (timelineFilterAgent) {
        const a = agentById(timelineFilterAgent);
        filterLabel.style.display = 'inline';
        filterLabel.textContent = `Filtered: ${a?.icon || ''} ${a?.name || timelineFilterAgent}`;
      } else {
        filterLabel.style.display = 'none';
      }

      tlCount.textContent = String(filtered.length);

      if (filtered.length === 0) {
        tlEntries.innerHTML = '<div class="tl-empty">No activity yet.<br>Connect to Gateway to see live messages.</div>';
        return;
      }

      tlEntries.innerHTML = filtered.map(e => {
        const ts = e.ts instanceof Date ? e.ts : new Date(e.ts);
        const hh = String(ts.getHours()).padStart(2,'0');
        const mm = String(ts.getMinutes()).padStart(2,'0');
        const ss = String(ts.getSeconds()).padStart(2,'0');
        const msgText = escapeHtml((e.message || '').slice(0, 100));
        return `<div class="tl-entry" data-agent="${e.agentId}">
          <span class="tl-ts">[${hh}:${mm}:${ss}]</span>
          <span class="tl-icon">${e.agentIcon || 'ü§ñ'}</span>
          <span class="tl-agent" style="color:${e.color}">${escapeHtml(e.agentName)}:</span>
          <span class="tl-msg">${msgText}</span>
        </div>`;
      }).join('');

      // Click entry to filter by agent
      tlEntries.querySelectorAll('.tl-entry').forEach(el => {
        el.style.cursor = 'pointer';
        el.addEventListener('click', () => {
          timelineFilterAgent = el.dataset.agent;
          renderTimeline();
        });
      });
    }

    function addTimelineEntry(agentId, message, timestamp) {
      const agent = agentById(agentId);
      if (!agent) return;
      const entry = {
        ts: timestamp ? new Date(timestamp) : new Date(),
        agentId,
        agentName: agent.name || agentId,
        agentIcon: agent.icon || 'ü§ñ',
        message: message || '',
        color: getAgentColor(agentId),
      };
      timelineData.unshift(entry);
      if (timelineData.length > TIMELINE_MAX) timelineData.length = TIMELINE_MAX;
      if (timelinePanel.classList.contains('open')) renderTimeline();
    }

    // ==============================================
    // --- Connection Flow Animation ---
    // ==============================================
    function triggerConnectionFlow(sourceAgentId, targetAgentId) {
      const srcNodeId = nodeIdForAgent(sourceAgentId);
      const tgtNodeId = nodeIdForAgent(targetAgentId);
      if (!srcNodeId || !tgtNodeId) return;
      // Try both directions
      const selectors = [
        `.connection.node_in_node-${tgtNodeId}.node_out_node-${srcNodeId}`,
        `.connection.node_in_node-${srcNodeId}.node_out_node-${tgtNodeId}`,
      ];
      for (const sel of selectors) {
        const connEl = container.querySelector(sel);
        if (connEl) {
          connEl.classList.add('flowing');
          setTimeout(() => connEl.classList.remove('flowing'), 5000);
        }
      }
    }

    // ==============================================
    // --- Hook into activity monitor for timeline + flow ---
    // ==============================================
    // Patch processSessionsUpdate to also feed timeline and trigger flow
    const _origProcessSessionsUpdate = processSessionsUpdate;
    processSessionsUpdate = function(sessions) {
      const prevSnapCopy = { ...activityState.previousSnapshot };

      // Call original
      _origProcessSessionsUpdate(sessions);

      // Detect new messages and feed timeline + flow
      for (const session of sessions) {
        const agent = matchSessionToAgent(session);
        if (!agent) continue;

        const sessionKey = session.sessionKey || session.key || session.id || '';
        const fingerprint = getSessionMessageFingerprint(session);
        const prev = prevSnapCopy[sessionKey];

        const isNew = prev && (
          (fingerprint.id && fingerprint.id !== prev.id) ||
          (fingerprint.ts && fingerprint.ts !== prev.ts) ||
          (fingerprint.content && fingerprint.content !== prev.content)
        );

        if (isNew) {
          // Build a dedupe key
          const dedupeKey = `${sessionKey}:${fingerprint.id || ''}:${fingerprint.ts || ''}`;
          if (timelineSeenKeys.has(dedupeKey)) continue;
          timelineSeenKeys.add(dedupeKey);
          // Keep seen keys bounded
          if (timelineSeenKeys.size > 200) {
            const arr = [...timelineSeenKeys];
            timelineSeenKeys = new Set(arr.slice(-100));
          }

          // Extract message content
          const msgs = session.messages || session.recentMessages || [];
          let msgContent = fingerprint.content || '';
          if (msgs.length > 0) {
            const latest = msgs[msgs.length - 1] || msgs[0];
            const raw = typeof latest.content === 'string' ? latest.content : (latest.content?.[0]?.text || '');
            msgContent = raw.slice(0, 100);
          }

          addTimelineEntry(agent.id, msgContent, fingerprint.ts);

          // Trigger flow animation ‚Äî find connections involving this agent
          // Flow from whoever sent TO this agent (or from this agent)
          const agentLinks = org.links.filter(l => l.source === agent.id || l.target === agent.id);
          for (const link of agentLinks) {
            triggerConnectionFlow(link.source, link.target);
          }
        }
      }
    };

    // Also close timeline when opening edit panel
    const _origOpenPanelFn = openPanel;

  })();
  </script>
</Base>
